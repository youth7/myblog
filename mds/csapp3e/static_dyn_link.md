# RISC-V/Linux下的静态链接和动态链接

本文在Linux环境下进行阐述，并假设用户将源码编译为可执行文件。



## 基本概念

关于链接的定义：

> Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed.   

——《CSAPP》



> **Linking** refers to the creation of a single executable file from multiple object files. .  

——[Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)



> In [computing](https://en.wikipedia.org/wiki/Computing), a **linker** or **link editor** is a computer [system program](https://en.wikipedia.org/wiki/System_software) that takes one or more [object files](https://en.wikipedia.org/wiki/Object_file) (generated by a [compiler](https://en.wikipedia.org/wiki/Compiler) or an [assembler](https://en.wikipedia.org/wiki/Assembler_(computing))) and combines them into a single [executable](https://en.wikipedia.org/wiki/Executable) file, [library](https://en.wikipedia.org/wiki/Library_(computing)) file, or another "object" file.

——[《Wikipedia》](https://en.wikipedia.org/wiki/Linker_(computing))



需要区分清楚编译（compile）、汇编（assembly）、链接（link）、加载（load）这4个不同的概念，它们的关系如下：

![](/imgs/compile_link_load.jpg)

链接的主要内容：

1. 地址与空间分配

   扫描各个目标文件，把里面的节按照类型合并起来，同时收集目标文件中的**符号引用**和**符号定义**到一个全局的集合中。完成这个步骤后得到可执行文件的整体结构已经确定，但其中一些符号的地址还需要重定位。

2. 符号解析和重定位

   根据步骤1中收集到的符号信息，为需要重定位的符号分配具体地址。这一步是链接的重中之重。静态链接的重定位在链接时就发生了，动态链接则将这个步骤推迟到程序加载或者运行时。



需要注意的是，编译时编译器为程序分配的地址空间都是从0开始的，此时并**没有面向虚拟地址空间（运行在支持虚拟地址的OS上）或者物理内存地址空间（运行在裸机上）**。不同的编译套件会根据自身的编译目标（target triple）在**链接阶段重置代码的基地址**。重置基地址并不会进行符号解析和重定位（在动态链接的例子中会展示），符号解析和重定位会发生在最后。





## 静态链接和动态链接的区别

链接阶段最重要的内容是符号解析和重定位，静态链接会在生成可执行文件的时候完成链接阶段的全部内容，而动态链接则会把这两个工作中的部分内容（例如解析动态链接库中的符号并进行重定位）推迟到运行时。

网上很多资料都说静态链接是*编译时*链接，其实这说话是不准确的。由上图可知编译包括：

1. 源代码编译到汇编代码

2. 汇编代码编译到目标文件

所以编译和链接的工作内容是完全不同的，编译并没不包含链接。但上面的错误说法其实也是可以理解的，他将编译+链接流程划分来两个阶段：*编译时*和*运行时*，*编译时*包括编译和链接，*运行时*包括程序加载和运行。因此【静态链接是*编译时*链接】这句话主要指静态链接在**运行前就完成了符号解析和重定位的工作**

[这个回答](https://stackoverflow.com/questions/311882/what-do-statically-linked-and-dynamically-linked-mean)中提到：

> You can see in the static case that the main program and C runtime  library are **linked together at link time**(by the developers). Since the  user typically cannot re-link the executable, they're stuck with the  behaviour of the library.   

> In the dynamic case, the main program is linked with the C runtime  import library (**something which declares what's in the dynamic library  but doesn't actually *define* it**). **This allows the linker to link even though the actual code is missing**.   

> Then, at runtime, the operating system loader does a late linking of  the main program with the C runtime DLL (dynamic link library or shared  library or other nomenclature).    

> The owner of the C runtime can drop in a new DLL at any time to  provide updates or bug fixes. As stated earlier, this has both  advantages and disadvantages.  

```sql
Phase     Static                    Dynamic
--------  ----------------------    ------------------------
          +---------+               +---------+
          | main.c  |               | main.c  |
          +---------+               +---------+
Compile........|.........................|...................
          +---------+ +---------+   +---------+ +--------+
          | main.o  | | crtlib  |   | main.o  | | crtimp |
          +---------+ +---------+   +---------+ +--------+
Link...........|..........|..............|...........|.......
               |          |              +-----------+(注意：这里crtimp没有像静态链接的crtlib那样完全打包进main中)
               |          |              |
          +---------+     |         +---------+ +--------+
          |  main   |-----+         |  main   | | crtdll |
          +---------+               +---------+ +--------+
Load/Run.......|.........................|..........|........
          +---------+               +---------+     |
          | main in |               | main in |-----+
          | memory  |               | memory  |
```





## 静态链接例子分析

为了简化问题，使用以下两个C语言程序进行编译和链接的演示

文件`a.c`的源码：

```c
extern int shared;

int main(void)
{
    int a = 100;
    swap(&a, &shared);
}
```

文件`b.c`的源码：

```c
int shared = 1;
void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```



其中编译环境信息为：

* 操作系统：Ubuntu 20.04.2 LTS

* 编译套件：[riscv64-unknown-elf.gcc-12.1.0](https://github.com/stnolting/riscv-gcc-prebuilt/releases/download/rv64imc-3.0.0/riscv64-unknown-elf.gcc-12.1.0.tar.gz)

使用该编译套件是因为RISCV历史包袱少，它的汇编代码比X86和ARM更加易懂，同时生成不依赖具体操作系统的ELF文件，减少不必要信息能够更好理解静态链接。（关于编译套件命名规则可以参考[这里](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html#id5)）



使用以下命令进行编译和链接：

```bash
#编译源代码但不链接
riscv64-unknown-elf-gcc -c a.c b.c

#链接上一步生成的目标文件
riscv64-unknown-elf-ld a.o b.o -e main -o ab

```

各个文件的作用如下：

* `a.o`：文件`a.c`编译后生成的目标文件

* `b.o`：文件`b.c`编译后生成的目标文件

* `ab`：文件`a.o`和`b.o`链接后的产物

### 链接前

从上述代码可知`a.c`引用了`b.c`中定义的全局变量，我们用`riscv64-unknown-elf-objdump -d a.o ab`来对比一下链接前后的`main`程序的汇编代码

```
a.o:     file format elf64-littleriscv


Disassembly of section .text:

0000000000000000 <main>:
   0:	1101                	addi	sp,sp,-32
   2:	ec06                	sd	ra,24(sp)
   4:	e822                	sd	s0,16(sp)
   6:	1000                	addi	s0,sp,32
   8:	06400793          	li	a5,100
   c:	fef42623          	sw	a5,-20(s0)
  10:	fec40713          	addi	a4,s0,-20
  14:	000007b7          	lui	a5,0x0
  18:	00078593          	mv	a1,a5
  1c:	853a                	mv	a0,a4
  1e:	00000097          	auipc	ra,0x0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>
  26:	4781                	li	a5,0
  28:	853e                	mv	a0,a5
  2a:	60e2                	ld	ra,24(sp)
  2c:	6442                	ld	s0,16(sp)
  2e:	6105                	addi	sp,sp,32
  30:	8082                	ret

ab:     file format elf64-littleriscv


Disassembly of section .text:

00000000000100e8 <main>:
   100e8:	1101                	addi	sp,sp,-32
   100ea:	ec06                	sd	ra,24(sp)
   100ec:	e822                	sd	s0,16(sp)
   100ee:	1000                	addi	s0,sp,32
   100f0:	06400793          	li	a5,100
   100f4:	fef42623          	sw	a5,-20(s0)
   100f8:	fec40713          	addi	a4,s0,-20
   100fc:	67c5                	lui	a5,0x11
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>
   10102:	853a                	mv	a0,a4
   10104:	010000ef          	jal	ra,10114 <swap>
   10108:	4781                	li	a5,0
   1010a:	853e                	mv	a0,a5
   1010c:	60e2                	ld	ra,24(sp)
   1010e:	6442                	ld	s0,16(sp)
   10110:	6105                	addi	sp,sp,32
   10112:	8082                	ret

```

可见在编译的时候，编译器对`main`中调用`swap`的生成了以下代码：

```
  14:	000007b7          	lui	a5,0x0	#计算shared地址的高20位，因为它暂时未知，所以暂设为0
  18:	00078593          	mv	a1,a5	#加载swap的第1个参数的地址到a1
  1c:	853a                	mv	a0,a4	#加载swap的第2个参数（即shared）的地址到a0
  1e:	00000097          	auipc	ra,0x0	#加载swap地址，将"立即数高20位"加上"PC当前值"存到ra，因为swap地址此时未知，因此立即数为0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>	#调用swap，这个伪指令相当于jalr x1, ra, 0 
```

这里有点奇怪的是计算`shared`地址的时候，不知道为何只包含了计算地址高20位的指令，没有包含低12位的计算。

`auipc`+`jalr`的作用如下：

* [AUIPC](https://jemu.oscc.cc/AUIPC) 与 [JALR](https://jemu.oscc.cc/JALR) 的 12 位立即数配合, 可以将控制流跳转到相对于 `PC` 的、32 位整型范围内的任意地址;

* 其中`auipc ra, 0x0`计算了`PC` + `swap`地址的前20位（存在常数参数中，即此例中的0x0），并存在`ra`中
* `jalr ra`扩展后相当于`jalr x1, ra, 0`，用上一步的结果（存在`ra`中），加上`swap`地址的低12位（存在常数参数中，即此例中的0x0）

注意这里只是编译时的结果，链接时当所有符号的地址都确定后，链接器会优化函数调用的过程（链接器松弛），下面我们会看到。



用`readelf -r a.o`检查一下重定位表：

```
Relocation section '.rela.text' at offset 0x1f0 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000014  00090000001a R_RISCV_HI20      0000000000000000 shared + 0
000000000014  000000000033 R_RISCV_RELAX                        0
000000000018  00090000001b R_RISCV_LO12_I    0000000000000000 shared + 0
000000000018  000000000033 R_RISCV_RELAX                        0
00000000001e  000a00000012 R_RISCV_CALL      0000000000000000 swap + 0
00000000001e  000000000033 R_RISCV_RELAX                        0

```

发现有`shared`有两个相关项，类型分别是`R_RISCV_HI20`和`R_RISCV_LO12_I`，它代表了`shared`的高20位和低12位都需要重定位。`swap`则更加不用说了，类型为`R_RISCV_CALL`，关于它的详细解读请参考[RISC-V ELF Specification](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#risc-v-elf-specification)

### 链接后

而经过链接之后则变成这样，主要是对重定位表中的符号进行重定位。

```
   100fc:	67c5                	lui	a5,0x11	#计算shared地址的高20位，此时因为已经将b.o也合并进来，所以编译器能够计算出它的地址
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>	#加上低12位得出shared的最终地址
   10102:	853a                	mv	a0,a4		#为swap传参
   10104:	010000ef          	jal	ra,10114 <swap>	#函数调用
```

用`readelf  -s ab`显示一下符号表：

```
Symbol table '.symtab' contains 19 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
...
    11: 0000000000010114    94 FUNC    GLOBAL DEFAULT    1 swap
    12: 0000000000011174     4 OBJECT  GLOBAL DEFAULT    2 shared
  
```

其中`shared`的计算方式为：高20位地址 + 低12位地址，其中高20位由指令`lui a5,0x11`确定，其值为0x11 << 12 =  69632。低12位为372，所以最终的地址为 69632 + 372 = 70004 = 0x11174，和符号表的结果完全一致。



而`swap`的调用则由之前的`auipc`+`jalr`改为了`jal ra,10114`，这就是下面说的“链接器松弛”技术



关于RISC-V汇编代码的一些基础知识可以参考：

* https://suda-morris.github.io/blog/cs/riscv.html

* [RISC-V指令集讲解（5）条件和无条件跳转指令](https://zhuanlan.zhihu.com/p/394860078)
* [《The RISC-V Reader: An Open Architecture Atlas》中文版](http://riscvbook.com/chinese/)前三章

其中一些重要的点是：

* 由于在单个 32 位指令中很难指定一个 32 位的地址，RV32I 的链接器通常需要为每个标签调整两条指令。
* 补充说明：链接器松弛（linker relaxation）
  跳转并链接指令（jump and link）中有 20 位的相对地址域，因此一条指令就足够跳到很远的位置。**尽管编译器为每个外部函数的跳转都生成了两条指令，很多时候其实一条就已经足够了。从两条指令到一条的优化同时节省了时间和空间开销，因此链接器会扫描几遍代码，尽可能地把两条指令替换为一条**。每次替换会导致函数和调用它的位置之间的距离缩短，所以链接器会多次扫描替换，直到代码不再改变。这个过程称为链接器松弛，名字来源于求解方程组的松弛技术。除了过程调用之外，对于 gp 指针±2KiB 范围内的数据访问， RISC-V 链接器也会使用一个全局指针替换掉 lui 和 auipc 两条指令。对 tp 指针±2KiB 范围内的线程局部变量访问也有类似的处理。  
* 一般来说，`LUI`和`JALR`配合使用可以跳转**32位绝对地址**范围，`AUIPC`和`JALR`配合可以跳转32位**相对于PC的**地址范围
* https://stackoverflow.com/questions/64695981/what-does-jalr-with-only-1-argument-and-offset-do



### 与x86的对比

再用系统自带的gcc套件重复上述过程，对比一下编译的结果

```bash
#编译源代码但不链接，注意需要加上-fno-stack-protecto否则会报错	
gcc -fno-stack-protector -c a.c b.c

#链接上一步生成的目标文件
ld a.o b.o -e main -o ab
```

TODO：分析上面的x86上的静态链接



### 总结

与动态链接相比，静态链接最大的特点是**链接时重定位**（动态链接是运行时重定位），而具体的重定位细节跟平台的指令集相关，学习时不必执着于地址的某些计算过程，只需知道链接器合理合并了所有目标文件并确定最终地址，然后进行最后的重定位。





## 动态链接例子分析

### 概述

静态链接的优点是生成的可执行文件能够独立执行，不需要额外的依赖，毕竟静态链接将所有第三方依赖都打包到可执行文件中了。但缺点也很明显：

* 体积大
* 浪费内存
* 升级更新难

动态链接的出现就是为了克服上述问题。它的做法是不在链接时将依赖的目标文件（为了叙述方便下面称其为lib.so）打包到可执行文件中，而是将lib.so加载到内存中（只有一份），当程序运行时用到lib.so中的对象，直接去内存中对应的地址读取即可，这种做法解决了上述的3个问题。

> lib.so被加载到多个进程的虚拟地址空间中，这样不就加载了多次吗，为何说它只有一份呢？事实上操作系统确实只加载了一份lib.so到物理内存，然后将lib.so映射到不同进程的虚拟地址空间中来实现共享。具体的过程可以参考：[动态链接器如何判断某个共享库已经加载进内存? - ruanyuanyu的回答 - 知乎](https://www.zhihu.com/question/270473854/answer/354570620)。这个过程在[CSAPP](https://hansimov.gitbook.io/csapp/part2/ch09-virtual-memory/9.8-memory-mapping)中也写得非常清晰：



因为lib.so在链接时不会被打包到可执行文件中，因此可执行文件对lib.so中各种符号的地址一无所知，只能在运行时等动态链接器把lib.so加载到进程的虚拟地址空间后，才能确定各个符号的值，进而访问lib.so中的各种对象。

> linux上*`共享对象（shared object）`*这个名词的起因或者可以看[这里](https://hansimov.gitbook.io/csapp/part2/ch09-virtual-memory/9.8-memory-mapping)：
>
> *一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。*

### 实现思路：PIC和基址重置

为了实现上述目标，lib.so中的代码（具体来说就是涉及地址访问的指令如地址跳转）必须做一些调整。因为lib.so是被多个进程共享的，所以可能被映射到不同的地址空间中。如果lib.so中的地址访问用到了绝对地址，则它无法被多个进程共享。

例如，下图是Linux在X86_64架构上的进程内存布局（虚拟地址空间），在stack和heap中间的那个区域就是lib.so（共享对象）加载后所在之处。假设程序p1启动时加载lib.so并对其中某个函数func调用地址重定位为0xFFFF。这个地址空间对p1来说是合法的，然而如果另外一个也依赖lib.so的程序p2在稍后启动，则运行到调用函数func的时很有可能会报错，因为0xFFFF对p2来说大概率是个非法地址。

![](/imgs/addr_rebase_layout.jpg)

> **注意：这种加载时重定位的方法会修改lib.so在物理内存中代码段中跟地址相关的数据。例如编译时因不知道func的地址会先生成`call 0x0000`这样的代码，0x0000表示先对func地址的留空。然后重定位时将地址留空的代码改为`call 0xFFFF`。如果不清楚这点是无法理解基址重置的缺陷的**）

解决上述问题要用到地址无关代码（PIC：position-independent code），**使得lib.so的代码不再跟具体的地址绑定。核心思想是将lib.so中可变部分（地址跳转中用到的绝对地址）和不变部分（.text节中的指令）分离开来。使得.text中不再含有地址信息，这样lib.so的代码在所有进程的地址空间中都以一致的方式存在，而地址相关部分则抽取到数据节（如`.got`）中，这些数据节在每个进程的地址空间中都有副本，因进程而异**。下面我们用具体代码来展示这个过程。



### 实现技术：GOT/PLT

关于GOT、PLT的介绍网上资料多如牛毛，这里不再重复，推荐参考以下文章：

* Linux动态链接为什么要用PLT和GOT表？ - 海枫的回答 - 知乎 https://www.zhihu.com/question/21249496/answer/126600437。

  这篇文章清晰描述了动态链接的两个阶段：**在链接阶段**，链接器收集相关符号信息之后生成地址无关的辅助代码；在**程序运行期**进行符号重定位。

  >  **链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用**。链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对[printf_stub](https://www.zhihu.com/search?q=printf_stub&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A126600437})做链接重定位，而运行时才对printf做运行时重定位。



大致的流程可以参考以下图片：

![](/imgs/pltgot.png)							![](/imgs/pltgot3.png)







### ELF中与动态链接相关的section

接下来我们使用以下代码演示动态链接中的一些重要部分，实验在RISC-V64上的Ubuntu 22.04 LTS进行，如何在搭建这个平台请参考[这里](https://gitee.com/tinylab/riscv-lab)。

`main.c`

```c
extern int my_fn(void);
static int main_local = 0x333;
int main(void)
{
    return my_fn();
}
```

`fn.c`

```c
#include <unistd.h>
#include <stdio.h>
int global_var_in_fn = 0x66;
static int local_var_in_fn = 0x77;
int my_fn(void)
{
    printf("&global_var_in_fn = %p\n", &global_var_in_fn);
    printf("&local_var_in_fn = %p\n", &local_var_in_fn);
    sleep(1000);
    return global_var_in_fn;
}
```

使用以下命令编译运行

```bash
gcc -fPIC -shared fn.c -o libfn.so
gcc -fPIC main.c libfn.so
export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH	#设置路径，以便运行时能够找到libfn.so，否则会报错
./a.out
```



在继续下面的实验前我们需要注意，ELF规范1.2中写道：

> The dynamic linking process resolves references either at process initialization time and/or at
> execution time. Some basic mechanisms need to be set up for a particular linkage model to
> work, and there are ELF sections and header elements reserved for this purpose. 
>
> **The actual definition of the linkage model is determined by the operating system and implementation.
> Therefore, the contents of these sections are both operating system and processor specific. (See
> the appendix at the end of Book III.)  **

可知动态链接的模型和实现是和CPU架构以及操作系统相关的，因此我们不要拘泥于一重定位的细节，而是掌握它的核心思想。而碰到一些具体参数的时候，需要参考[RISCV专属的ELF规范](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#risc-v-elf-specification)



#### .interp

执行命令`objdump -s -j .interp  a.out`查看运行时负责初始化的动态链接器，它存在于`.interp`中

```bash
a.out:     file format elf64-littleriscv

Contents of section .interp:
 0270 2f6c6962 2f6c642d 6c696e75 782d7269  /lib/ld-linux-ri
 0280 73637636 342d6c70 3634642e 736f2e31  scv64-lp64d.so.1
 0290 00
```

和x86平台不同，当前平台使用的是`/lib/ld-linux-riscv64-lp64d.so.1`。关于动态链接器的一些介绍可以看[这里](https://www.man7.org/linux/man-pages/man8/ld.so.8.html)

#### .dynamic

动态链接的所有信息的入口，用`readelf -d libfn.so`查看

```bash
Dynamic section at offset 0xe60 contains 22 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x0000000000000019 (INIT_ARRAY)         0x1e50
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x1e58
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x1f0
 0x0000000000000005 (STRTAB)             0x2f0
 0x0000000000000006 (SYMTAB)             0x218
 0x000000000000000a (STRSZ)              127 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000003 (PLTGOT)             0x2010
 0x0000000000000002 (PLTRELSZ)           48 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x450
 0x0000000000000007 (RELA)               0x3a8
 0x0000000000000008 (RELASZ)             216 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x388
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x370
 0x000000006ffffff9 (RELACOUNT)          3
 0x0000000000000000 (NULL)               0x0
```

每项的具体含义见[这里](https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html)，以及ELF规范1.2，其中需要留意的是以下几个：

* `DT_PLTGOT`：一个与PLT或者GOT相关地址，  在Intel架构中它指向了GOT的首元素。而它的当前值是0x2010，通过查找section table得知这一项指向了`.got`。

* `DT_JMPREL`：指向与PLT表相关的**relocation entries**。如果此项出现的话， `DT_PLTRELSZ` and `DT_PLTREL`也必须出现。

* `DT_PLTRELSZ`：表明所有relocation entries的总大小。

* `DT_PLTREL`：`DT_JMPREL`所指向的relocation entries的类型（`DT_REL` 或 `DT_RELA`），所有relocation entries的类型都是相同的。
* `DT_RELA`：一个**relocation table **的地址，重定位表中的每一项都附带有addends（用于地址修正）。如果此项出现的话，`DT_RELASZ` 和`DT_RELAENT` 也必须出现。
  * `DT_REL` ：类似`DT_RELA`，但不附带addends
  



所以`DT_JMPREL`和`DT_RELA`究竟有什么区别（**relocation entries** VS **relocation table**  ？）从上面的输出中我们看到`DT_JMPREL`和`DT_RELA`的值分别是0x450和0x3a8。非常巧合的是，这和动态链接的两个重定位表是一样的

```bash
readelf -S libfn.so  | grep rela
  [ 7] .rela.dyn         RELA             00000000000003a8  000003a8
  [ 8] .rela.plt         RELA             0000000000000450  00000450
```

所以我们可以推理**`DT_JMPREL`和`DT_RELA`分别指向了`.rela.plt`和`.rela.dyn`**。



#### 动态符号表（.dynsym）

动态链接符号表，用` readelf -sD  libfn.so`查看

```bash
Symbol table for image contains 9 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
......
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sleep@GLIBC_2.27 (2)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.27 (2)
......
     7: 000000000000054a    76 FUNC    GLOBAL DEFAULT   10 my_fn
     8: 0000000000002008     4 OBJECT  GLOBAL DEFAULT   16 global_var_in_fn
```

可见fn.c中定义的两个符号（`my_fn`和`global_var_in_fn`）以及引用自外部的两个符号（`sleep`和`printf`）都出现了，但是外部符号的名称和代码中稍稍不一样。去GLIBC验证一下：`readelf -sD  /usr/lib/riscv64-linux-gnu/libc.so.6 | grep -E ' sleep| printf'`

```bash
  1547: 0000000000047a5a    84 FUNC    GLOBAL DEFAULT   12 printf@@GLIBC_2.27
  2036: 0000000000091cd8   100 FUNC    WEAK   DEFAULT   12 sleep@@GLIBC_2.27
```

发现名称引用没有问题，确实是多了个后缀。



#### 重定位表（`.rela.dyn`和`.rela.plt`）

用`readelf -r  libfn.so`检查一下

```bash
Relocation section '.rela.dyn' at offset 0x3a8 contains 7 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000001e50  000000000003 R_RISCV_RELATIVE                     548 #指向.init_array
000000001e58  000000000003 R_RISCV_RELATIVE                     50e #指向.fini_array
000000002000  000000000003 R_RISCV_RELATIVE                     2000#指向.data
000000002038  000200000002 R_RISCV_64        0000000000000000 _ITM_deregisterTM[...] + 0
000000002040  000800000002 R_RISCV_64        0000000000002008 global_var_in_fn + 0
000000002048  000500000002 R_RISCV_64        0000000000000000 __cxa_finalize@GLIBC_2.27 + 0
000000002050  000600000002 R_RISCV_64        0000000000000000 _ITM_registerTMCl[...] + 0



Relocation section '.rela.plt' at offset 0x450 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000002020  000300000005 R_RISCV_JUMP_SLOT 0000000000000000 sleep@GLIBC_2.27 + 0
000000002028  000400000005 R_RISCV_JUMP_SLOT 0000000000000000 printf@GLIBC_2.27 + 0
```

`sleep`和`printf`需要重定位那是理所当然的，但`global_var_in_fn`是fn.c定义的全部变量，为何也出现在重定位表呢？个人猜测这是因为`global_var_in_fn`是一个全局变量，同时fn.c的代码是地址无关的。

ELF规范1.2中是这样定义的`Offset`的

> This member gives the location at which to apply the relocation  action. Different object files have slightly different interpretations for this member.
>
> For a relocatable file, the value indicates a section offset. The  relocation section itself describes how to modify another section in the file. Relocation offsets designate a storage unit within the second section.
>
> For an executable or shared object, the value indicates the virtual  address of the storage unit affected by the relocation. This information makes the relocation entries more useful for the runtime linker.

可知**重定位表中的都是虚拟地址**。而类型为`R_RISCV_64`或`R_RISCV_RELATIVE`6个地址，其范围是0x2020~0x2050，在下面关于`.got`的分析中我们可以看到它的虚拟地址范围是0x2010~0x2058，正好能够覆盖重定位表中那6个地址。





#### `.plt`

```bash
readelf -S libfn.so
...
[ 9] .plt              PROGBITS         0000000000000480  00000480
       0000000000000040  0000000000000010  AX       0     0     16
..       
```

可知`.plt`的虚拟地址是0x480，总大小是0x40，表中每一项的大小是0x10（注意第一项是例外，见下面）。看一下里面的具体内容

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ objdump -d -j .plt  libfn.so

libfn.so:     file format elf64-littleriscv


Disassembly of section .plt:

0000000000000480 <.plt>:
 480:	00002397          	auipc	t2,0x2
 484:	41c30333          	sub	t1,t1,t3
 488:	b903be03          	ld	t3,-1136(t2) # 2010 <__TMC_END__>
 48c:	fd430313          	addi	t1,t1,-44
 490:	b9038293          	addi	t0,t2,-1136
 494:	00135313          	srli	t1,t1,0x1
 498:	0082b283          	ld	t0,8(t0)
 49c:	000e0067          	jr	t3

00000000000004a0 <sleep@plt>:
 4a0:	00002e17          	auipc	t3,0x2
 4a4:	b80e3e03          	ld	t3,-1152(t3) # 2020 <sleep@GLIBC_2.27>
 4a8:	000e0367          	jalr	t1,t3
 4ac:	00000013          	nop

00000000000004b0 <printf@plt>:
 4b0:	00002e17          	auipc	t3,0x2
 4b4:	b78e3e03          	ld	t3,-1160(t3) # 2028 <printf@GLIBC_2.27>
 4b8:	000e0367          	jalr	t1,t3
 4bc:	00000013          	nop
```

这似乎很难懂，参考[RISCV专属的ELF规范](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#risc-v-elf-specification)的相关章节：

> The first entry of a shared object PLT is a special entry that calls `_dl_runtime_resolve` to resolve the GOT offset for the called function. ......The first entry in the PLT occupies **two 16 byte entries**:
>
> ```
> 1:  auipc  t2, %pcrel_hi(.got.plt)
>     sub    t1, t1, t3               # shifted .got.plt offset + hdr size + 12
>     l[w|d] t3, %pcrel_lo(1b)(t2)    # _dl_runtime_resolve
>     addi   t1, t1, -(hdr size + 12) # shifted .got.plt offset
>     addi   t0, t2, %pcrel_lo(1b)    # &.got.plt
>     srli   t1, t1, log2(16/PTRSIZE) # .got.plt offset
>     l[w|d] t0, PTRSIZE(t0)          # link map
>     jr     t3
> ```
>
> Subsequent function entry stubs in the PLT take up **16 bytes** and load a function pointer from the GOT. **On the first call to a function, the entry redirects to the first PLT entry which calls `_dl_runtime_resolve` and fills in the GOT entry for subsequent calls to the function**:
>
> ```
> 1:  auipc   t3, %pcrel_hi(function@.got.plt)
>     l[w|d]  t3, %pcrel_lo(1b)(t3)
>     jalr    t1, t3
>     nop
> ```

可知`.plt`的第1项占用32个字节，它包含了一段能够初始化GOT的代码（简称其为`init`）；剩余的每一项16字节，它包含了一些代码，这些代码会从未初始化过的GOT中获得一个函数指针（指向`init`），通过`init`来初始化GOT。其实这就是网上广泛流传的关于PLT和GOT的协作过程，**唯一不同的是RISCV中`.plt`的结构与X86-64有较大差别。在X86-64中，.got的前三项分别是`.dynamic`节、link_map结构、`_dl_runtime_resolve` 的地址。而RISCV中除了第一项是调用`_dl_runtime_resolve` 的特殊项（占用的空间是常规项的2倍）外，其它都是常规的PLT项，**。

#### `.got`

> A global offset table's format and interpretation are processor-specific.  
>
> ...
>
> The actual contents and form of this table depend upon the processor

可见GOT是平台相关的，先看看GOT的地址

```bash
readelf -S libfn.so
...
  [17] .got              PROGBITS         0000000000002010  00001010
       0000000000000048  0000000000000008  WA       0     0     8
...       
```

可知GOT在ELF中的偏移是0x1010，每一项8个字节，总大小0x48字节。将GOT打印出来看看里面每一项的值

```
hexdump -x -s 0x00001010 -n 0x48 libfn.so
0001010    ffff    ffff    ffff    ffff    0000    0000    0000    0000
0001020    0480    0000    0000    0000    0480    0000    0000    0000
0001030    1e60    0000    0000    0000    0000    0000    0000    0000
0001040    0000    0000    0000    0000    0000    0000    0000    0000
0001050    0000    0000    0000    0000
0001058
```

从上可见：

* 第1项：全部位都用1填充，在X86_64中这一项是预留的，用于保存`.dynamic`的地址，但RISCV中没有找到相关规范
* 第2项：全部位用0填充，意义不明。猜测为了跟`.plt`的结构保持一致而故意填充0（`.plt`中第一项大小为常规项的2倍）
* 第3~4项：值为0x480，这明显就是未初始化前的值，指向`.plt`。
* 第5项：值为0x1e60，指向了`.dynamic`
* 第6~9项：值全部为0，原理不明，似乎也不是因为对齐而导致的pading



至此，根据上面的分析可以画出下面的静态结构图：

<!--

图的结构至少包含以下信息

* 整体结构，按照ELF的section table顺序展示
* `.dynamic`中各个重要元素的指向：
  * `DT_PLTGOT`：指向`.got`
  * `DT_JMPREL`：指向`.rela.plt`
  * ``DT_RELA`：指向`.rela.dyn`

* `.plt`中各个元素：最重要是首项，用于初始化`.got`
* `.got`中各个元素的指向：未初始化前都指向了`.plt`的首项

-->



### 运行时分析

上面已经从静态角度分析了动态链接的一些细节，但动态链接真正生效是在运行时，具体表现为以下两点：

* GOT在运行时的初始化
* GOT在各个进程的地址空间都是一个副本（这是实现IPC的关键）

TODO：具体的debug过程







 





## 参考

* [Linking & Loading](https://www.cs.fsu.edu/~baker/opsys/notes/linking.html)
* [Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)
* [RISC-V ELF Specification](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#global-offset-table)
* [CSAPP](https://hansimov.gitbook.io/csapp/part2/ch07-linking/7.12-position-independent-code)