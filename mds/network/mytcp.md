# 整体模型

本文是根据 *《计算机网络.自顶向下方法》* 的3.4节整理而成，主要描述了**可靠数据的传输原理**。具体是先假设一个简单理想的通讯场景，然后逐步往上添加各种约束并提供解决方案。让读者在这个过程中理解TCP的可靠传输是怎么工作的。注意虽然3.4节**并不是**对TCP协议的具体描述，但是它是一个通用的模型，原理也是适用于TCP。

整个场景的模型如下所示： 

![rdt_model.jpg](/imgs/rdt_model.jpg)

左边描述了整个通讯体系提供的服务，从上到下分为3层：
* 应用层：上层实体，需要调用下层的服务来发送/接收数据
* 传输层：为上层提供**可靠的传输服务**，对于上层来说它是一个**可靠的信道**，但是它的下层是**不可靠的信道**
* 网络层：不可靠的信道，数据有可能丢失/损坏

整个模型还有一个假设：分组将以它们发送的次序进行交付，即底层信道不会对分组进行重新排序。

# 停等协议
下面先用文字把思路整理出来，为了方便描述简称发送端为s（sender）接收方为r（receiver），**作者依次描述了3中情况下r和s会面对什么问题，然后通过什么手段来实现可靠数据的传输**。

## 情况1.0：信道完全可靠，数据包不会损坏和丢失  
s只需要将数据发送出去即可，无需等待r的任何反馈，因为信道完全可靠，r必定能正确接收数据。双方的状态图如下：  
![rdt_1.0](/imgs/rdt_1.0.jpg)

每个图形的意义如下（后面类似不再重复）：
* 虚线：初始状态
* 灰色圆圈：发送或者接收方的状态
* 弧形箭头：协议从一个状态变迁到另外一个状态
* 横线上方：引起状态变迁的事件
* 横线下方：事件发生时采取的动作
* `Λ`：缺少事件或者缺少动作



## 情况2.0：信道不完全可靠，数据包会损坏，但是不会丢失
为了解决数据包损坏的问题，引入了以下手段：  
* 差错检测：r用于检查数据包是否损坏，通过校验和之类的方式实现
* 反馈：r告知s数据是否正确，通过ack和nak实现
* 重传：s重新发送受损的数据

此时双方的状态图如下：
![rdt_2.0](/imgs/rdt_2.0.jpg)

## 情况2.1：ack和nak也有可能损坏
2.0中忽略了ack和nak损坏的情况，如果必须考虑这种境况，则s在收到ack/nak的时候必须校验它们，如果发现ack/nak损坏，或者收到正常的nak就重传之前的包。这种做法对于r来说，会存在这样的问题：假设r之前回复了一个ack给s但是这个ack损坏了，s检测到损坏的ack之后立马重传之前的包，r收到重传的包之后，因为它之前回复的是ack而不是nak，根据2.0协议它会认为这个包是新的数据包，**即r无法区分接收的包是新包还是重传的包**。


此时的应对方案是
* 引入序列号（只需1bit，能表示0或1即可）

在停等协议中我们的序列号只需1个bit，通过比较当前包的序列号和之前的包的序列号，r就知道这个包是重传还是新数据包，此时双方的状态如下（因为需要考虑ack/nak的损坏，双方的状态都加倍了）：  
![rdt_2.1](/imgs/rdt_2.1.jpg)
		
## 情况3.0：信道完全不可靠，数据可能损坏和丢失 
当s发送数据给r的时候，会遇到以下几种问题：
* 数据包丢失，r接收不到
* r接收到，但是ack/nak丢失
* r接收到，但是ack/nak经过一个很大的延迟才到达

对于上面的两种情况，s的策略都是超时重传，此时发送方的状态图如下：
![rdt_3.0](/imgs/rdt_3.0.jpg)

## 依然存在的问题
从情况1.0到3.0，通过引入各种手段我们基本实现了可靠数据的传输。但是它有一个缺陷，必须等到上一个包发送完毕之后，才能发送下一个包，因此也称为**停等协议**。使用这种协议导致信道利用率太低，为提高吞吐出现了下面所说的**流水线可靠数据传输协议**

# 流水线可靠数据传输协议
为了克服停等协议的的低效，**s需要持续地发送包而无需等待，然后批量确认** 带来的影响有：
* 序列号的范围扩大
* s和r都需要缓冲多个分组
* 所需序列号的范围和对缓冲的要求取决于协议是如何处理丢失、损坏、超时的分组。


在流水线可靠数据传输协议中，当s持续地发送包的时候，如果其中一个被发送的包出现了错误（包丢失、ack/nak丢失等），它要如何重新发送数据呢，有两种主流的方法，分别是**回退N步**和**选择重传**

## 回退N步(GBN) 
GBN也叫滑动窗口协议
### 对于GBN中的发送方
* 需要维护两个变量：base和nextseqnum，它将所有数据分为以下4段：
	* [0, base-1]：已经发送并且得到确认的数据
	* [base, nextseqnum-1]：已经发但是没有得到确认的数据
	* [nextseqnum, base + N -1]：等待发送的数据
	* [base + N -1, +∞]：不可用的数据

	如下图所示，其中N就是窗口长度  
	![gbn](/imgs/gbn.jpg)
* s收到发送序号为n的ack的时候，意味着 **[0,n]的包已经被r成功接收，这称为积累确认**。
* 如果出现超时，则s会**重发所有未被确认的包**（即图中的黄色部分）。

积累确认的好处可以通过以下例子来体现：
* s发送了包p1，p2，p3
* r成功接收了p1，p2，p3并且回复ack1，ack2，ack3
* ack2因为网络原因丢失，s只接收到ack1，ack3
* 但是s无需等待ack2就可以得知p2已经被r接收，因为根据积累确认的协议，r只会在p2和p3都被接收后才会回复ack3，如果p2未被接收而p3成功接收是不会回复ack3的

通过积累确认，即使某些ack丢失了，也不会影响到s，只要后续的ack被收到。

### 对于GBN中的接收方
如果上一次成功接收的包是n-1，则期望下一个成功接收的包是n。如果不是n则直接抛弃这个包。因为s会重发所有未被确认的包（包括n）。

GBN本质是用多个包去填充流水线，优点是提高了信道的利用率，缺点是即使单个包丢失，也会引起全部未被确定的包重传，**当窗口N较大且网络延迟较大的时候尤其严重。** 
从这个图可以看到它的弊端：因为pkt2的丢失，使得pkt2~5都重传，即使pkt3~5其实已经成功发送到r 
![gbn_disadv](/imgs/gbn_disadv.jpg)


为了克服这个问题，需要使用到选择重传。

## 选择重传（SR）

### SR中的发送方
SR中的发送方需要完成以下几件事情：
* 从上层接收数据，根据窗口的状态发送或者缓存这个数据
* 为发出的数据设置一个定时器，以便超时重传
* 当收到ack时候，在窗口中标记其对应的数据，如果该数据的序号等于send_base，则窗口向前滑动一定的距离

它的窗口图如下：  
![sr_s_windows](/imgs/sr_s_windows.jpg)

### SR中的接收方
SR中的接收方需要完成以下几件事情：
* 如果收到的数据序号在[rcv_base, rcv_base + N - 1]中，则回复一个ack并在窗口标记该数据。如果该数据序号等于rcv_base，则根矿口向前滑动一定距离。否则缓存这个数据 
* 如果收到的数据序号在[rcv_base-N, rcv_base - 1]中（已经接收过的旧数据），则回复一个ack。注意这个步骤很重要，再一次接收到这些旧数据，**说明s没有收到旧数据的ack，如果不再次发送这些ack，s的窗口就不会向前移动**，最终使得s停止发送数据。
* 其它情况忽略这个分组

它的窗口图如下：  
![sr_s_windows](/imgs/sr_r_windows.jpg)


注意双方的窗口中都有一个标有★号的数据，仔细体会这个数据是如何将双方连接起来



## GBN和SR的比较
||GBN|SR|
|-|-|-|
|确认|积累确认|每个数据包都需要独立确认|
|定时器|1个定时器|每个数据包都有定时器|
|重传|重传所有未被确认的包|只重传丢失的数据|
|缓存|不缓存乱序数据|缓存乱序数据|

关于GBN和SR的讨论可以看[这里](https://www.zhihu.com/question/44602610)



# 用Node.js模拟流水线可靠数据传输协议
有空再补上代码吧，太累了



