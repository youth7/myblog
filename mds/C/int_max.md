


CSAPP上提到，最小的整型数据是-2147483647-1，而不是直接简单写成-2147483648。看了下/usr/include/limits.h，我们看到确实如作者所说：

```C
#  define INT_MIN       (-INT_MAX - 1)
#  define INT_MAX       2147483647
```
查阅了很多资料之后终于明白了原因。


# C语言确定常数类型的规则
当编译器碰到一个数字常量的时候它是怎么确定数字的类型呢？C11规范给出了下表
![c_list][1]

可以看到，对于无后缀的十进制常量，将会按照以下顺序去确定类型
```C
	int
	long int
	long long int
```

因此，如果我们将INT_MIN定义成-2147483648，则当用户使用这个宏的时候，编译器首先会获取整数2147483648，它超出了int类型所能表达的最大值（2147483647），因此根据上表，编译器会把INT_MIN的类型确定为long int而不是我们所期待的int，而(-INT_MAX - 1)则不会有这个问题。我们可以通过以下程序验证一下（64位的Fedora26）：
```C
#include<stdio.h>
int main(void) {
	int a = -2147483648;
	int b = -2147483647-1;	
	printf("%d %d %lu %lu\n", a, b, sizeof(2147483647), sizeof(2147483648));
}
```
会输出
```bash
-2147483648 -2147483648 4 8
```
说明2147483648已经被编译器识别为long int了，有趣的是a经过类型自动转换之后的最终值依然和b一样。  
可以看到由于补码的不对称性（小于0的整型数量比大于0的整型数量多1），造成了这个微妙的问题。


[1]:/imgs/int_list.jpg