# 静态链接和动态链接中的重定位

本文在Linux环境下进行阐述，并假设用户将源码编译为可执行文件。



## 基本概念

关于链接的定义：

> Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed.   

——《CSAPP》



> **Linking** refers to the creation of a single executable file from multiple object files. .  

——[Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)



> In [computing](https://en.wikipedia.org/wiki/Computing), a **linker** or **link editor** is a computer [system program](https://en.wikipedia.org/wiki/System_software) that takes one or more [object files](https://en.wikipedia.org/wiki/Object_file) (generated by a [compiler](https://en.wikipedia.org/wiki/Compiler) or an [assembler](https://en.wikipedia.org/wiki/Assembler_(computing))) and combines them into a single [executable](https://en.wikipedia.org/wiki/Executable) file, [library](https://en.wikipedia.org/wiki/Library_(computing)) file, or another "object" file.

——[《Wikipedia》](https://en.wikipedia.org/wiki/Linker_(computing))



需要区分清楚编译（compile）、链接（link）、加载（load）这3个不同的概念，它们的关系如下：

![](/imgs/compile_link_load.jpg)



链接的主要步骤：

1. 地址与空间分配（Address and Storage Allocation）
2. 符号解析（Symbol Resolution）
3. 重定位（Relocation）



本文对比静态链接和动态链接在步骤3的差异，主要分析了动态链接中重定位的实现原理。







## 静态链接例子分析（链接时重定位）

为了简化问题，使用以下两个C语言程序进行编译和链接的演示

文件`a.c`的源码：

```c
extern int shared;

int main(void)
{
    int a = 100;
    swap(&a, &shared);
}
```

文件`b.c`的源码：

```c
int shared = 1;
void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```



其中编译环境信息为：

* 操作系统：Ubuntu 20.04.4 LTS

* 编译工具：[riscv64-unknown-elf.gcc-12.1.0](https://github.com/stnolting/riscv-gcc-prebuilt/releases/download/rv64imc-3.0.0/riscv64-unknown-elf.gcc-12.1.0.tar.gz)

使用该编译套件是因为RISCV历史包袱少，它的汇编代码比X86和ARM更加易懂。（关于编译套件命名规则可以参考[这里](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html#id5)）



使用以下命令进行编译和链接：

```bash
#编译源代码但不链接
riscv64-unknown-elf-gcc -c a.c b.c

#链接上一步生成的目标文件
riscv64-unknown-elf-ld a.o b.o -e main -o ab
```

各个文件的作用如下：

* `a.o`：文件`a.c`编译后生成的目标文件

* `b.o`：文件`b.c`编译后生成的目标文件

* `ab`：文件`a.o`和`b.o`链接后的产物



先验证上面说的第一步：地址与空间分配。此过程中链接器会把类型相似的节进行合并，并为合并后的节重新分配虚拟地址空间，我们用`.text`节为例。













再用系统自带的gcc套件重复上述过程，对比一下编译的结果

```bash
#编译源代码但不链接，注意需要加上-fno-stack-protecto否则会报错	
gcc -fno-stack-protector -c a.c b.c

#链接上一步生成的目标文件
ld a.o b.o -e main -o ab
```





















静态链接的思路很简洁，归纳起来是两点：

1. 首先，源码编译为目标文件(.o文件)时，程序中不确定的符号地址全部预留空白，留待链接时再解析出具体值。

2. 然后，将目标文件和静态链接库（.a文件）链接为一个可执行文件，可执行文件**包含它所依赖的全部内容**。在此过程中需要解决步骤1未完成的符号地址解析工作。

与动态链接不同的是，它在是在**链接时**完成符号解析工作。而动态链接则是**加载时**完成符号解析工作，因为动态链接**在链接时并不知道所依赖的共享对象会加载到程序虚拟地址空间的具体位置**，因此无法做符号解析。但静态链接则没有这个问题，因为静态链接会将.a文件的内容也整合到最终的可执行文件当中。



下面介绍一下静态链接在RISC-V下的具体过程：TODO







## 动态链接（运行时重定位）

动态链接的思路是这样的：

1. TODO

2. TODO



### 动态链接库如何映射到程序的虚拟地址空间

其中最关键的一点是共享对象的装载方式，即共享对象如何映射到目标程序的地址空间，有以下几种思路

* 固定地址装载

  把共享对象(.so文件)装载到目标程序地址空间的固定的地址，例如规定*lib1.so*装载到地址空间*a1*，*lib2.so*装载到地址空间*a2*......如此类推。因为所有动态链接库的地址都是规定好的，那链接时解析符号的具体地址也不难了。

  显然这是一种局限性非常大的方法，至少有以下缺陷：

  * 地址冲突：不同的开发团体采用不同的映射规则，难以统一以致冲突。
  * 地址浪费：因为共享对象只能加载到固定的地址，所以即使程序没有用到某个共享对象，也不能使用这个地址。
  * 升级：一旦升级了共享对象导致加载的地址产生变化，则需要将目标程序重新链接。这个问题非常严重，如果不解决则一旦某个共享对象升级了，所有依赖它的目标文件都需要重新链接，这是不能接受的。

  TODO：搜索静态链接库内容 

* 基址重置（装载时重定位）

* 地址无关代码（PIC） 
  * 模块内
    * 通过获取当前PC值来实现相对地址访问
  * 模块间
    * GOT
    * PLT





## 参考

* [Linking & Loading](https://www.cs.fsu.edu/~baker/opsys/notes/linking.html)
* [Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)
