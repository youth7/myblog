# 一、RISC-V 典型完整引导流程

RISC-V 嵌入式系统的引导是**多阶段接力**模式，Mask ROM 作为 “第一棒”，仅负责启动的初始环节，后续依赖多级引导程序逐步加载复杂功能，最终启动内核。以下是基于真实嵌入式 RISC-V 芯片（如 SiFive FE310、全志 D1）的通用流程，按执行顺序拆解：

## 1. **阶段 1：Mask ROM 引导（上电第一执行，固化于芯片）**

   - **存储位置**：芯片内置的 Mask ROM（例如你提到的 `0x0000_1000~0x0000_1FFF`，4KB 空间）。
   - **核心代码**：出厂固化的**最小化 ROM Bootloader**，代码量极小。
   - 核心操作：
     1. 芯片上电复位后，CPU 的程序计数器（PC）被硬件强制指向 Mask ROM 起始地址，执行第一条指令。
     2. 仅初始化**最核心的硬件**：如 CPU 核心、片上总线、基础时钟，不初始化复杂外设（如网卡、显示屏）。
     3. 检查外部存储介质（如 SPI Flash、SD 卡）是否存在合法的二级引导程序（通常是 SPL）。
     4. 将外部存储中的二级引导程序加载到片上 SRAM（如 DTIM，地址 `0x8000_0000` 附近），随后 PC 跳转到 SRAM 中二级引导程序的入口地址。
   - **特点**：只读不可修改，功能极简，仅解决 “如何启动下一级程序” 的问题。

## 2. **阶段 2：SPL 引导（第二阶段，存储于外部 Flash）**

   - **SPL** 全称 Secondary Program Loader（二级程序加载器），是 U-Boot 引导程序的精简版。

   - **存储位置**：外部可读写存储（如 SPI Flash 的固定分区）。

   - 核心操作：

     1. 初始化扩展硬件：如 DDR 内存控制器、SPI Flash 控制器，此时系统可使用更大容量的 DDR 内存。
     2. 从外部存储（如 Flash 的另一个分区）加载完整版 U-Boot 到 DDR 内存中。
     3. 跳转执行 DDR 中的完整版 U-Boot。
     
   - **核心作用**：弥补 Mask ROM 容量小、功能弱的缺陷，为加载完整版引导程序铺路。

## 3. **阶段 3：完整版 U-Boot 引导（第三阶段，运行于 DDR 内存）**

   - **U-Boot** 是嵌入式领域通用的开源引导程序，功能全面，相当于 RISC-V 系统的 “功能强化版 BIOS”。

   - **运行位置**：大容量 DDR 内存（如 `0x8000_0000` 开始的 DRAM）。

   - 核心操作：

     1. 初始化全量外设：如串口、网口、SD 卡、显示屏等，用户可通过串口输入命令交互。
     2. 读取引导配置（如环境变量），确定内核镜像的存储位置（如 Flash 或网络服务器）。
     3. 将内核镜像（如 Linux 内核的 `Image` 文件）和设备树（DTB，描述硬件信息）加载到 DDR 内存的指定地址。
     4. 完成准备工作后，跳转到内核镜像的入口地址，移交系统控制权。

## 4. **阶段 4：内核与根文件系统启动（最终阶段）**

   - **内核启动**：内核接管后，初始化操作系统核心功能（进程管理、内存管理、文件系统等）。
   - **根文件系统挂载**：内核加载并挂载根文件系统（存储应用程序、配置文件等）。
   - **用户态启动**：最终启动用户态程序和服务，系统进入可使用状态。

# 二、RISC-V 引导流程 vs x86 BIOS/UEFI 引导流程

为了更清晰看出差异，下面通过对比表格展现两者的核心区别，同时解释 Mask ROM 为何不等于 x86 的 BIOS：

| 对比维度         | RISC-V 引导流程                                              | x86 引导流程                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 启动初始入口     | Mask ROM（固化极简引导代码，仅负责加载下一级程序，无交互、不可更新） | BIOS/UEFI（存储于主板 ROM 芯片，功能完整）                   |
| 核心中间引导层   | SPL + U-Boot（U-Boot 提供交互和全量硬件初始化，可更新）      | BIOS 直接引导，或 UEFI 引导管理器（功能更现代化，支持图形界面） |
| 硬件初始化分工   | 分阶段逐步扩展（Mask ROM 仅核心硬件 → SPL 扩展硬件 → U-Boot 全量硬件） | BIOS/UEFI 一次性完成大部分硬件初始化                         |
| 灵活性与可更新性 | Mask ROM 不可更新，U-Boot/SPL 可通过工具更新，适配性强       | BIOS/UEFI 可通过厂商工具更新，支持更多主板定制功能           |
| 生态定位         | Mask ROM 是 “启动入口”，U-Boot 承担类似 BIOS 的核心功能      | BIOS/UEFI 是 “一站式引导 + 硬件管理”，无单独的 “二级引导” 刚需 |

# 三、关键总结

1. **Mask ROM ≠ BIOS**：Mask ROM 仅存储极简引导代码，是 RISC-V 启动的 “起点”；而 x86 的 BIOS 是功能完整的引导 + 硬件管理固件。RISC-V 中真正承担类似 BIOS 功能的是 **U-Boot**。
2. **多阶段引导的原因**：核心是受限于 Mask ROM 的 “只读、小容量” 特性 —— 无法存储复杂代码，只能通过 “接力” 方式逐步加载功能更强的引导程序，最终满足内核启动的需求。
3. **QEMU 模拟的简化逻辑**：你之前用 `qemu-system-riscv32` 加 `-bios none` 时，QEMU 直接跳过了 Mask ROM→SPL→U-Boot 的完整流程，将用户程序（`start.elf`）直接加载到 `0x8000_0000`，本质是模拟了 “引导流程全部完成后” 的状态，方便开发者调试。



# 附录：X86中的BIOS VS BOOTLOADER

需要注意，BIOS似乎只是X86才有的概念，在RISCV中没有这个东西。

| **维度**     | **BIOS**                                                     | **BOOTLOADER**                                               |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**     | 固化在主板芯片中的**硬件固件**（属于硬件层面）               | 存储在启动设备（如硬盘）中的**软件程序**（属于软件层面）     |
| **核心功能** | 1. 硬件初始化（如内存、显卡、硬盘检测）<br /> 2. 检测启动设备（按启动顺序查找） <br/>3. 找到并移交控制权给 BOOTLOADER | 1. 从启动设备中定位操作系统内核<br/> 2. 加载内核到内存并启动<br/> 3. （部分高级功能）提供启动菜单（如双系统选择） |
| **存储位置** | 主板上的 ROM/EEPROM 芯片（断电不丢失）                       | 启动设备的第一个扇区（如硬盘的 MBR）                         |
| **运行阶段** | 计算机通电后第一个运行的程序（启动最早期）                   | BIOS 完成硬件检测后运行（启动中期）                          |
| **依赖关系** | 不依赖 BOOTLOADER，但需要找到 BOOTLOADER 才能继续启动        | 完全依赖 BIOS 启动（由 BIOS 加载并执行）                     |

BIOS是**硬件厂商（注意）**固化在ROM中的一段代码，它只熟悉主板，对BOOTLOADER一无所知，只是双方协议好BOOTLOADER的位置，以便BIOS自检结束后能够将控制权转交给BOOTLOADER。