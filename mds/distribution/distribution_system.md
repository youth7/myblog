# 1. 认识分布式系统

* 特点：
  * **不共享时钟：难以通过时间来定义两个事件的顺序**
* 好处：
  * 高性能：提供大量的计算存储能力
  * 扩展性
  * 高可用：通过冗余数据或者计算实现
* 挑战：
  * 网络不可靠：消息会**丢失**、**迟到**、**重复**、**乱序**（TCP能从一定程度上处理这些问题，提供一个可靠连接的抽象）
  * 部分失效：操作缺少原子性
  * 时钟问题：

* 一些意外的结论：
  * 从远程服务器内存中读取数据要比直接从磁盘上读取要快？

# 2. 分布式系统的模型

## 系统模型

根据不同类型的故障抽象出不同的系统模型，分别有：

* 按照网络链路划分：

  |              | 不丢失 | 不重复 | 有序 | 不无中生有 |
  | ------------ | ------ | ------ | ---- | ---------- |
  | 可靠链路     | ✅      | ✅      | ✅    | ✅          |
  | 公平损失链路 | ❌      | ❌      | ❌    | ✅          |
  | 任意链路     | ❌      | ❌      | ❌    | ❌          |

  * 通过**加密传输，可以将3转化为2**（假设攻击者不会阻断链路）
  * 通过**数据重传，可以将2转化为1**（因为2会假设所有**网络分区只会持续有限时间**）
  * 重传是个非常有效的手段，有时候工程上没有完美的解，但可以找到足够可用的解

* 按照故障类型分：

  * 崩溃-停止（crash-stop）：
  * 崩溃-恢复（crash-recovery）：
  * 拜占庭故障（Byzantine）：

  除了航空、加密货币等小部分领域需要拜占庭容错，其它大部分领域使用崩溃模型就已经足够

* 按时间类型划分：

  * 同步：消息的响应时间在一个**有限且已知的范围内**
  * 异步：消息的响应时间是无限的
  * 部分同步：系统在大部分时间内是同步的，但会因为偶尔的故障转变为异步

## 消息传递语义

* 最多一次
* 最少一次
* 精确一次：通过重传实现**精确处理一次**，从而模拟**精确传递一次**



**书中讨论的模型默认是【可靠链路】 +【崩溃-停止/崩溃-恢复】 + 【部分同步】**





# 3. 分布式数据基础

* 分区提供了**扩展性和高性能**
* 复制（即冗余）提供了**高可用**

## 分区（partition）

* 水平分区：即分布式系统中的分片（Shardlng ），在本文的上下文里，**分区和分片是同义词，都是指将数据分布在不同的物理机器上**。
* 垂直分区：不讨论



不同系统中对分区的称呼

> What we call a *partition* here is called a *shard* in MongoDB, Elasticsearch, and SolrCloud; it’s known as a *region* in HBase, a *tablet* in Bigtable, a *vnode* in Cassandra and Riak, and a *vBucket* in Couchbase. **However, *partitioning* is the most established term**, so we’ll stick with that
>
> * *shard*: MongoDB/ Elasticsearch/ SolrCloud:
> * *region*: HBase
> * *tablet*: Bigtable
> * *vnode*: Cassandra/ Riak
> * *vBucket*: Couchbase



分区算法有以下几种：

### 范围分区

指根据**指定的关键字（分区键）**将数据集拆分为**若干连续的范围**，每个范围存储到**—个单独的节点上**。

* 优点
  * 实现简单
  * 对分区键进行范围查询，当查询范围较小且落在同一个节点上时性能良好
  * 通过**修改范围的边界**就能够增加或减少该范围的数据，从而达到重新分区均衡负载

* 缺点  

  * 无法使用分区键以外的关键字进行范围查询
  * 查询范围较大且位于多个节点时，性能较差
  * 可能产生数据倾斜（这其实是分区键选择不当造成的）或请求流量不均匀（此时虽然数据均匀分布，但请求流量不均匀，此时需要对热点数据进行拆分）

  

### 哈希分区

将**指定的关键字（分区键）经过—个哈希函数计算**，根据计算得到的值来决定该数据集的分区  

* 优点
  * 分布均匀
* 缺点
  * 不支持范围查找
  * 增删新节点时候会造成数据大规模移动（增删节点以为着要修改原哈希函数，因为一个哈希值就必须有一个节点对应）

### 一致性哈希

是对哈希分区算法的改进

* 优点
  * 增删节点时候不会导致数据大规模调整，只需要调整被增/删节点的相邻节点的数据，且不需要修改哈希函数（优化了上述哈希算法的第二个缺点，有更好的扩展性）
* 缺点
  * 不支持范围查找
  * 删除节点N的时候，N往顺时针方向的下一个节点将会接收N的全部数据，这使得可能会导致数据分布不均。可以使用虚拟节点来缓解这个问题，这样当删除物理节点的时候，如果安排妥当的话，被删节点的数据能够均匀分布到其它虚拟节点（即均匀分布到各个物理节点）



分区的挑战有两个：

* 某些操作需要跨分区访问数据
* 跨分区实现事务



## 复制（Replication）

* 优点：

  * 增强安全性和可用性

  * 增加吞吐量

  * 减少往返时间

* 缺点：增加了系统的复杂性

复制有以下三种类型：

### 单主复制（主从复制）

分为3类：同步复制、异步复制、半同步复制 

* 优点：
  * 简单，容易实现
  * 仅在主节点进行并发的写操作（从节点只需要同步日志文件，是属于线性化后的写操作，不属于并发），能够保证数据一致性
  * **对于读操作**，单主复制是可扩展的（通过增加多个从节点）
* 缺点：
  * 写操作集中在主节点上难以扩展（扩展性）
  * 主节点宕机后无法立即切换到从节点，因为数据可能尚未同步到从节点（可用性）

### 多主复制

一般很少使用，**主节点之间的数据冲突**问题过于复杂，抵消了它带来的好处。常见的解决数据冲突的策略有：

* 客户端决策
* Last Write Win
* 因果关系追踪
* 无冲突数据类型

与其时候解决数据冲突，可以通过一些策略来回避数据冲突，例如让**各个主节点负责不同部分**的数据写入。在这种情况下**主节点之间的数据同步**就退化为单主复制，而从节点可以从任意一个主节点同步数据。



> 一些全球性的数据中心，为了降低地区间写请求的响应时间，才会使用这种方式



### 无主复制（Dynamo-Style）

上述两种基于master的复制算法，其缺点是一旦master宕机了集群就无法写入。无主复制算法克服了这个问题，它写入时候往集群多个节点（可以是全部）发送写请求，一旦若干节点确认写入成功，则认为这个写请求成功。

无主复制关键之处是需要理解Quorum数据冗余机制，即理解公式：
$$
W + R > N
$$
它有两层意义：

* 如果想写入的数据能够下次一定被读取到，**则需要根据系统的IO能力去配置写入/读取的节点比例**，以确保写入的新数据一定被读取到
* $R$ 越小读取性能越好（因为需要读取较少节点），$W$ 越小写入性能越好（因为需要写入较少节点）

> Quorum机制是分布式系统重用来保证数据冗余和最终一致性的一种算法。

## CAP定理

了解CAP的两个关键：

1. 对C的理解
2. 对A和P的精确理解，并区分出它们的不同

C是一个大多数人都会混淆的问题，在后续的章节再仔细讨论。最难的是理解A和P







* A：**对所有请求**，系统都必须在**合理的时间**内返回**合理的响应**
  
  可用性要求的是对于**任意请求都能得到响应**，意味着**即使出现网络分区所有节点都能够提供服务**
  
* P：分区容忍的重点在于出现网络分区之后，系统仍然是可用的（包括部分可用）

  这里关键需要区分P和A有什么不同，摘抄一段知乎的答案，这个答案表明了再CP情况下，系统此时可能只是**部分可用**。**部分可用**指系统此时处于下面两种状态：

  * **全部节点**只提供读功能；
  * **部分节**点提供**读写功能**，剩下的节点不可用。

  此时并不是对所有请求都能响应，例如情况1是全部节点都不能响应写请求，情况2部分节点完全不能响应请求

  >**分区容忍就是指分布式系统在出现网络分区的时候，仍然能继续运行，对外提供服务。**注意，这里所说的仍然能够对外提供服务跟可用性的要求不一样，可用性要求的是对于**任意请求都能得到响应**，意味着即使出现网络分区**所有节点都能够提供服务**。而分区容忍的重点在于出现网络分区之后，**系统仍然是可用的（包括部分可用）**。
  >
  >链接：https://www.zhihu.com/question/54105974/answer/2144019181

## PACELC定理

## 一致性模型

## 隔离级别

## 一致性和隔离级别的对比

# 4. 分布式共识

# 5. 分布式事务

# 6. 时间和事件顺序

# 7. 案例研究

