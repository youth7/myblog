# 静态链接和动态链接中的重定位

本文在Linux环境下进行阐述，并假设用户将源码编译为可执行文件。



## 基本概念

关于链接的定义：

> Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed.   

——《CSAPP》



> **Linking** refers to the creation of a single executable file from multiple object files. .  

——[Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)



> In [computing](https://en.wikipedia.org/wiki/Computing), a **linker** or **link editor** is a computer [system program](https://en.wikipedia.org/wiki/System_software) that takes one or more [object files](https://en.wikipedia.org/wiki/Object_file) (generated by a [compiler](https://en.wikipedia.org/wiki/Compiler) or an [assembler](https://en.wikipedia.org/wiki/Assembler_(computing))) and combines them into a single [executable](https://en.wikipedia.org/wiki/Executable) file, [library](https://en.wikipedia.org/wiki/Library_(computing)) file, or another "object" file.

——[《Wikipedia》](https://en.wikipedia.org/wiki/Linker_(computing))



需要区分清楚编译（compile）、链接（link）、加载（load）这3个不同的概念，它们的关系如下：

![](/imgs/compile_link_load.jpg)



链接的主要内容：

1. 地址与空间分配

   扫描各个目标文件，把里面的节按照类型合并起来，同时收集目标文件中的**符号引用**和**符号定义**到一个全局的集合中。完成这个步骤后得到可执行文件的整体结构已经确定，但其中一些符号的地址还需要重定位。

2. 符号解析和重定位

   根据步骤1中收集到的符号信息，为需要重定位的符号分配具体地址。这一步是链接的重中之重。静态链接的重定位在链接时就发生了，动态链接则将这个步骤推迟到程序加载或者运行时。



需要注意的是，编译时编译器为程序分配的地址空间都是从0开始的，此时并**没有面向虚拟地址空间（运行在支持虚拟地址的OS上）或者物理内存地址空间（运行在裸机上）**。不同的编译套件会根据自身的编译目标（target triple）在**链接阶段重置代码的基地址**。重置基地址并不会进行符号解析和重定位（在动态链接的例子中会展示），符号解析和重定位会发生在最后。



## 静态链接例子分析

为了简化问题，使用以下两个C语言程序进行编译和链接的演示

文件`a.c`的源码：

```c
extern int shared;

int main(void)
{
    int a = 100;
    swap(&a, &shared);
}
```

文件`b.c`的源码：

```c
int shared = 1;
void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```



其中编译环境信息为：

* 操作系统：Ubuntu 20.04.4 LTS

* 编译工具：[riscv64-unknown-elf.gcc-12.1.0](https://github.com/stnolting/riscv-gcc-prebuilt/releases/download/rv64imc-3.0.0/riscv64-unknown-elf.gcc-12.1.0.tar.gz)

使用该编译套件是因为RISCV历史包袱少，它的汇编代码比X86和ARM更加易懂。（关于编译套件命名规则可以参考[这里](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html#id5)）



使用以下命令进行编译和链接：

```bash
#编译源代码但不链接
riscv64-unknown-elf-gcc -c a.c b.c

#链接上一步生成的目标文件
riscv64-unknown-elf-ld a.o b.o -e main -o ab

```

各个文件的作用如下：

* `a.o`：文件`a.c`编译后生成的目标文件

* `b.o`：文件`b.c`编译后生成的目标文件

* `ab`：文件`a.o`和`b.o`链接后的产物



从上述代码可知`a.c`引用了`b.c`中定义的全局变量，我们用`riscv64-unknown-elf-objdump -d a.o ab`来对比一下链接前后的`main`程序的汇编代码

```
a.o:     file format elf64-littleriscv


Disassembly of section .text:

0000000000000000 <main>:
   0:	1101                	addi	sp,sp,-32
   2:	ec06                	sd	ra,24(sp)
   4:	e822                	sd	s0,16(sp)
   6:	1000                	addi	s0,sp,32
   8:	06400793          	li	a5,100
   c:	fef42623          	sw	a5,-20(s0)
  10:	fec40713          	addi	a4,s0,-20
  14:	000007b7          	lui	a5,0x0
  18:	00078593          	mv	a1,a5
  1c:	853a                	mv	a0,a4
  1e:	00000097          	auipc	ra,0x0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>
  26:	4781                	li	a5,0
  28:	853e                	mv	a0,a5
  2a:	60e2                	ld	ra,24(sp)
  2c:	6442                	ld	s0,16(sp)
  2e:	6105                	addi	sp,sp,32
  30:	8082                	ret

ab:     file format elf64-littleriscv


Disassembly of section .text:

00000000000100e8 <main>:
   100e8:	1101                	addi	sp,sp,-32
   100ea:	ec06                	sd	ra,24(sp)
   100ec:	e822                	sd	s0,16(sp)
   100ee:	1000                	addi	s0,sp,32
   100f0:	06400793          	li	a5,100
   100f4:	fef42623          	sw	a5,-20(s0)
   100f8:	fec40713          	addi	a4,s0,-20
   100fc:	67c5                	lui	a5,0x11
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>
   10102:	853a                	mv	a0,a4
   10104:	010000ef          	jal	ra,10114 <swap>
   10108:	4781                	li	a5,0
   1010a:	853e                	mv	a0,a5
   1010c:	60e2                	ld	ra,24(sp)
   1010e:	6442                	ld	s0,16(sp)
   10110:	6105                	addi	sp,sp,32
   10112:	8082                	ret

```

可见在编译的时候，编译器对`main`中调用`swap`的生成了以下代码：

```
  14:	000007b7          	lui	a5,0x0	#计算shared地址的高20位，因为它暂时未知，所以暂设为0
  18:	00078593          	mv	a1,a5	#加载swap的第1个参数的地址到a1
  1c:	853a                	mv	a0,a4	#加载swap的第2个参数（即shared）的地址到a0
  1e:	00000097          	auipc	ra,0x0	#加载swap地址，将"立即数高20位"加上"PC当前值"存到ra，因为swap地址此时未知，因此立即数为0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>	#调用swap，这个伪指令相当于jalr x1, ra, 0 
```

这里有点奇怪的是计算`shared`地址的时候，不知道为何只包含了计算地址高20位的指令，没有包含低12位的计算。

`auipc`+`jalr`的作用如下：

* [AUIPC](https://jemu.oscc.cc/AUIPC) 与 [JALR](https://jemu.oscc.cc/JALR) 的 12 位立即数配合, 可以将控制流跳转到相对于 `PC` 的、32 位整型范围内的任意地址;

* 其中`auipc ra, 0x0`计算了`PC` + `swap`地址的前20位（存在常数参数中，即此例中的0x0），并存在`ra`中
* `jalr ra`扩展后相当于`jalr x1, ra, 0`，用上一步的结果（存在`ra`中），加上`swap`地址的低12位（存在常数参数中，即此例中的0x0）

注意这里只是编译时的结果，链接时候当所有符号的地址都确定的时候，链接器会优化函数调用的过程（链接器松弛），下面我们会看到。



用`readelf -r a.o`检查一下重定位表：

```
Relocation section '.rela.text' at offset 0x1f0 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000014  00090000001a R_RISCV_HI20      0000000000000000 shared + 0
000000000014  000000000033 R_RISCV_RELAX                        0
000000000018  00090000001b R_RISCV_LO12_I    0000000000000000 shared + 0
000000000018  000000000033 R_RISCV_RELAX                        0
00000000001e  000a00000012 R_RISCV_CALL      0000000000000000 swap + 0
00000000001e  000000000033 R_RISCV_RELAX                        0

```

发现有`shared`有两个相关项，类型分别是`R_RISCV_HI20`和`R_RISCV_LO12_I`，它代表了`shared`的高20位和低12位都需要重定位。`swap`则更加不用说了，类型为`R_RISCV_CALL`，关于它的详细解读请参考[RISC-V ELF Specification](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#risc-v-elf-specification)



而经过链接之后则变成这样，主要是对重定位表中的符号进行重定位。

```
   100fc:	67c5                	lui	a5,0x11	#计算shared地址的高20位，此时因为已经将b.o也合并进来，所以它是确定的
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>	#加上低12位得出shared的最终地址
   10102:	853a                	mv	a0,a4		#为swap传参
   10104:	010000ef          	jal	ra,10114 <swap>	#函数调用
```

用`readelf  -s ab`显示一下符号表：

```
Symbol table '.symtab' contains 19 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
...
    11: 0000000000010114    94 FUNC    GLOBAL DEFAULT    1 swap
    12: 0000000000011174     4 OBJECT  GLOBAL DEFAULT    2 shared
  
```

其中`shared`的计算方式为：高20位地址 + 低12位地址，其中高20位由指令`lui a5,0x11`确定，其值为0x11 << 12 =  69632。低12位为372，所以最终的地址为 69632 + 372 = 70004 = 0x11174，和符号表的结果完全一致。



而`swap`的调用则由之前的`auipc`+`jalr`改为了`jal ra,10114`，这就是下面说的“链接器松弛”技术



关于RISC-V汇编代码的一些基础知识可以参考：

* [RISC-V指令集讲解（5）条件和无条件跳转指令](https://zhuanlan.zhihu.com/p/394860078)
* 《RISC-V手册》前三章

其中一些重要的点是：

* 由于在单个 32 位指令中很难指定一个 32 位的地址，RV32I 的链接器通常需要为每个标签调整两条指令。
* 补充说明：链接器松弛（linker relaxation）
  跳转并链接指令（jump and link）中有 20 位的相对地址域，因此一条指令就足够跳到很远的位置。**尽管编译器为每个外部函数的跳转都生成了两条指令，很多时候其实一条就已经足够了。从两条指令到一条的优化同时节省了时间和空间开销，因此链接器会扫描几遍代码，尽可能地把两条指令替换为一条**。每次替换会导致函数和调用它的位置之间的距离缩短，所以链接器会多次扫描替换，直到代码不再改变。这个过程称为链接器松弛，名字来源于求解方程组的松弛技术。除了过程调用之外，对于 gp 指针±2KiB 范围内的数据访问， RISC-V 链接器也会使用一个全局指针替换掉 lui 和 auipc 两条指令。对 tp 指针±2KiB 范围内的线程局部变量访问也有类似的处理。  
* 一般来说，`LUI`和`JALR`配合使用可以跳转**32位绝对地址**范围，`AUIPC`和`JALR`配合可以跳转32位**相对于PC的**地址范围
* https://stackoverflow.com/questions/64695981/what-does-jalr-with-only-1-argument-and-offset-do





再用系统自带的gcc套件重复上述过程，对比一下编译的结果

```bash
#编译源代码但不链接，注意需要加上-fno-stack-protecto否则会报错	
gcc -fno-stack-protector -c a.c b.c

#链接上一步生成的目标文件
ld a.o b.o -e main -o ab
```



与动态链接相比，静态链接最大的特点是**链接时重定位**（动态链接是运行时重定位），而具体的重定位细节跟指令集相关，不必执着于地址的某些计算过程，只需知道链接器合理合并了所有目标文件并计算出最终地址，然后进行最后的重定位。







## 动态链接

动态链接的思路是这样的：

1. TODO

2. TODO



### 动态链接库如何映射到程序的虚拟地址空间

其中最关键的一点是共享对象的装载方式，即共享对象如何映射到目标程序的地址空间，有以下几种思路

* 固定地址装载

  把共享对象(.so文件)装载到目标程序地址空间的固定的地址，例如规定*lib1.so*装载到地址空间*a1*，*lib2.so*装载到地址空间*a2*......如此类推。因为所有动态链接库的地址都是规定好的，那链接时解析符号的具体地址也不难了。

  显然这是一种局限性非常大的方法，至少有以下缺陷：

  * 地址冲突：不同的开发团体采用不同的映射规则，难以统一以致冲突。
  * 地址浪费：因为共享对象只能加载到固定的地址，所以即使程序没有用到某个共享对象，也不能使用这个地址。
  * 升级：一旦升级了共享对象导致加载的地址产生变化，则需要将目标程序重新链接。这个问题非常严重，如果不解决则一旦某个共享对象升级了，所有依赖它的目标文件都需要重新链接，这是不能接受的。

  TODO：搜索静态链接库内容 

* 基址重置（装载时重定位）

* 地址无关代码（PIC） 
  * 模块内
    * 通过获取当前PC值来实现相对地址访问
  * 模块间
    * GOT
    * PLT





## 参考

* [Linking & Loading](https://www.cs.fsu.edu/~baker/opsys/notes/linking.html)
* [Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)
