## UART是如何区分读写模式的？

1. 读 LCR（0x3F8+0x03）→ 看 DLAB 位（第 7 位）→ 确定是 “波特率配置模式” 还是 “数据收发模式”；
2. 若为数据收发模式：
   - 读 LSR（0x3F8+0x05）→ DR 位（第 0 位）判断是否可读、THRE 位（第 5 位）判断是否可写；
   - 读 IIR（0x3F8+0x02）→ 看 FIFO 状态位（第 6、7 位）判断是否启用 FIFO；
3. 若为波特率模式：
   1. 地址偏移量为0的地方是DLL，存16位除数的低8位
   2. 地址偏移量为1的地方是DLM，存16位除数的高8位

> 16550 UART 偏移 0x02 的标准名称是 **Interrupt Identification Register（IIR，中断识别寄存器）**，并非 ISR（Interrupt Status Register，中断状态寄存器），这是术语混用导致的常见误解。

## 如果读写模式是可以同时存在的，那UART对同一个地址进行读写的时候， 数据不会错乱吗？

> 你的这个疑问直击 16550 UART 设计的核心 ——**“同一端口地址却能区分读写操作、甚至对应不同寄存器”，本质是硬件层面的 “地址 + 操作类型” 译码逻辑，和内存的 “同一地址 = 同一存储位置” 完全不同**。
>
> 简单说：UART 的 “端口地址” 不是 “内存地址”，它是 CPU 对硬件设备的 “访问编号”，硬件会根据「地址 + 读 / 写指令」来决定响应哪个寄存器，而非像内存那样 “地址唯一对应存储单元”。
>
> 下面分两层讲清楚这个逻辑：
>
> ### 一、先分清：内存访问 vs 外设端口访问（核心差异）
>
> | 维度     | 内存访问（RAM/ROM）                      | 外设端口访问（UART / 网卡）                    |
> | -------- | ---------------------------------------- | ---------------------------------------------- |
> | 地址本质 | 物理存储单元的唯一编号（如 0x100000）    | 硬件设备的 “访问通道编号”（如 0x3F8）          |
> | 读写逻辑 | 读 / 写同一地址 → 操作**同一个存储单元** | 读 / 写同一地址 → 硬件译码后**操作不同寄存器** |
> | 实现主体 | 内存控制器（被动响应，无逻辑判断）       | 外设硬件电路（**主动译码，判断操作类型**）     |
>
> 
>
> ### 二、16550 UART 同一地址区分读写的硬件实现
>
> #### 硬件译码逻辑示意图（简化版）：
>
> ```plaintext
> CPU 发出 → [地址信号（0x3F8）] + [读写控制信号（读/写）] → 16550 译码器
>          ├─ 地址匹配 0x3F8 + 写信号 → 选通 THR 寄存器
>           └─ 地址匹配 0x3F8 + 读信号 → 选通 RBR 寄存器
>```
> 
> 关键：THR 和 RBR 是物理上独立的两个寄存器，只是共享了同一个 “访问地址”，硬件通过「读写控制信号」来区分到底操作哪一个 —— 这和内存 “一个地址对应一个存储单元” 的逻辑完全不同。
> 
> 
> 
>### 三、再延伸：DLAB （Divisor Latch Access Bit）位如何进一步复用地址？
> 
>你之前关注的 DLAB 位（LCR 第 7 位），是在 “地址 + 读写” 的基础上，增加了第二层译码条件：
> 
> - **DLAB=1 时**：端口 0x3F8 对应「除数锁存低位（DLL）」（读 / 写都操作 DLL），端口 0x3F9 对应「除数锁存高位（DLM）」；
>- **DLAB=0 时**：端口 0x3F8 对应 RBR（读）/THR（写），端口 0x3F9 对应「中断使能寄存器（IER）」；
> 
>#### 完整译码逻辑：
> 
>```plaintext
> CPU 信号 → [地址] + [读写] + [DLAB 位状态] → 16550 译码器
>           ├─ 地址=0x3F8 + 写 + DLAB=0 → 选通 THR
>          ├─ 地址=0x3F8 + 读 + DLAB=0 → 选通 RBR
>           ├─ 地址=0x3F8 + 写 + DLAB=1 → 选通 DLL
>          ├─ 地址=0x3F8 + 读 + DLAB=1 → 选通 DLL
>           └─ ... 其他地址/状态组合 ...
> ```
> 
> 本质是：**DLAB 位作为 “模式开关”**，让同一地址在不同模式下对应不同寄存器 —— 硬件内部会把 DLAB 位的状态和地址、读写信号一起输入译码器，最终决定激活哪个寄存器的电路。
> 
> ### 总结
> 
> 16550 同一地址能区分读写、甚至对应不同寄存器，核心是：
>
> 1. UART 的 “端口地址” 是硬件访问编号，不是内存存储单元地址；
>2. 硬件通过「地址 + 读写控制信号 + DLAB 模式位」的组合译码，决定操作哪个独立的物理寄存器；
> 3. 这是外设设计中 “地址复用” 的经典方案，目的是节省 I/O 地址资源。
>
> 简单记：**内存地址是 “一对一”（地址→存储单元），外设端口地址是 “多对一”（地址 + 操作 →寄存器）** —— 这就是为什么同一端口地址能实现读写独立。



# 寄存器列表

## LSR(Line Status Register)

该寄存器提供需要发送的数据的状态，其中每一个bit的含义如下：

| 位编号（Bit） | 英文缩写                                     | 功能名称         | 作用说明                                                     |
| ------------- | -------------------------------------------- | ---------------- | ------------------------------------------------------------ |
| 0             | `DR`（Data Ready）                           | 数据就绪位       | 0 = 接收数据寄存器（RDR）为空；<br />1 = RDR 已接收到完整字符，CPU 需读取数据。<br />**清零方式**：读取后该位自动清零 |
| 1             | `OE`（Overrun Error）                        | 溢出错位         | 0 = 无溢出错误；<br />1 = 前一个字符未被 CPU 读取，新字符又被接收 → 旧数据丢失。<br />**清零方式**：读取 LSR 后再读取 RDR |
| 2             | `PE`（Parity Error）                         | 奇偶校验错位     | 仅当 LCR 启用奇偶校验时有效；<br />0 = 无校验错误；<br />1 = 接收字符的奇偶校验结果与配置不符。<br />**清零方式**：读取 LSR 后再读取 RDR |
| 3             | `FE`（Framing Error）                        | 帧格式错位       | 0 = 接收帧格式正确（起始位 + 数据位 + 校验位 + 停止位完整）；<br />1 = 未检测到有效的停止位（如波特率不匹配、线路干扰）。<br />**清零方式**：读取 LSR 后再读取 RDR |
| 4             | `BI`（Break Interrupt）                      | 断路中断位       | 0 = 无断路信号；<br />1 = 接收端检测到断路信号（TX 持续低电平超过 1 帧时长）。<br />**清零方式**：读取 LSR 后，断路信号消失 |
| 5             | `THRE`（Transmitter Holding Register Empty） | 发送保持寄存器空 | 0 = 发送保持寄存器（THR）有数据，正在发送；<br />1 = THR 中的数据已全部移入发送移位寄存器 → CPU 可写入下一个字符。<br />**清零方式**：CPU 向 THR 写入新数据 |
| 6             | `TEMT`（Transmitter Empty）                  | 发送器空         | 0 = 发送移位寄存器或 THR 有数据；<br />1 = THR 和发送移位寄存器均为空 → 发送完全完成（比 THRE 更严格）。<br />**自动清零**：向 THR 写入数据时清零 |
| 7             | `RFE`（Receiver FIFO Error）                 | 接收 FIFO 错误位 | 仅适用于带 FIFO 的 UART（如 16550，8250 无此位）；<br />0 = 接收 FIFO 无错误；<br />1 = 接收 FIFO 中至少有一个字符存在 OE/PE/FE 错误。<br />**清零方式**：读取 LSR 后再读取 RDR |





## LCR （Line Control Register）  

用来配置以下内容：

* 字长
* stop bits的长度
* 奇偶校验

其中每一个bit的含义如下：



| 位编号（Bit） | 英文缩写                           | 功能名称           | 作用说明                                                     |
| ------------- | ---------------------------------- | ------------------ | ------------------------------------------------------------ |
| 0             | `DLS0`（Data Length Select 0）     | 数据位长度选择位 0 | 与 Bit1 配合，定义 UART 帧的数据位长度：<br />00=5 位 <br />01=6 位 <br />10=7 位<br />11=8 位 |
| 1             | `DLS1`（Data Length Select 1）     | 数据位长度选择位 1 | 同上，与 Bit0 联动配置数据位                                 |
| 2             | `STB`（Stop Bit Select）           | 停止位长度选择位   | 定义停止位数量，**需结合数据位（`DLS`）长度**：<br />当`STB`=0时，1 位停止位；<br />当`STB`=1时，且`DLS1`=5时，1.5 位停止位<br />当`STB`=1时，且`DLS1`=6/7/8时， 2 位停止位 |
| 3             | `EPS`（Even Parity Select）        | 偶校验选择位       | 仅当 Bit5（`PE`）=1 时生效，与 Bit4 联动配置校验类型         |
| 4             | `PSEL`（Parity Select）            | 校验类型选择位     | 仅当 Bit5（`PE`）=1 时生效：<br />00 = 奇校验 <br />01 = 偶校验 <br />10 = 强制 1 校验<br />11 = 强制 0 校验 |
| 5             | `PE`（Parity Enable）              | 奇偶校验使能位     | 奇偶校验总开关：<br />0 = 禁用校验（帧中无校验位）；<br />1 = 启用校验（需配置 Bit3/4 确定类型） |
| 6             | `SB`（Set Break）                  | 断路信号控制位     | 控制发送断路信号：<br />0 = 正常工作（TX 空闲为高电平）；<br />1 = 强制 TX 输出低电平（发送断路信号） |
| 7             | `DLAB`（Divisor Latch Access Bit） | 除数锁存器访问位   | 波特率配置关键位：<br />0 = 访问 UART 数据寄存器 / 中断寄存器；<br />1 = 访问波特率除数锁存器（DLH/DLL） |







## RBR和RHR

在 **16550 UART** 芯片中，**RBR（Receive Buffer Register，接收缓冲寄存器）** 和 **RHR（Receive Holding Register，接收保持寄存器）本质是同一个物理寄存器**，二者的差异仅源于**历史命名迭代**，功能完全一致。



## IER（Interrupt Enable Register，中断使能寄存器）

| 位编号（Bit） | 英文缩写 | 功能名称                            | 作用说明                                                     |
| :------------ | -------- | :---------------------------------- | :----------------------------------------------------------- |
| 0             | ERBFI    | receive holding register interrupt  | 1 = 开启RBR满中断（缓冲区有数据时触发）；<br />0 = 禁用该中断，无 FIFO 时对应 “接收数据可用” 中断 |
| 1             | ETBEI    | transmit holding register interrupt | 1 = 开启THR空中断（缓冲区为空时触发，提示 CPU 填充新数据）；<br />0 = 禁用该中断 |
| 2             | ELSI     | receive line status interrupt       | 1 = 接收line status的中断（发生帧错误、奇偶错误、溢出错误、中止信号时触发）；<br />0 = 禁用该中断 |
| 3             | EDSSI    | modem status interrup               | 1 = 开启MODEM 状态中断（CTS、DSR 等 MODEM 状态变化时触发）；<br />0 = 禁用该中断，仅适用于带 MODEM 接口的 UART |
| 4~7           | -        | 保留位                              | 无实际功能，读写操作时建议置 0，16550 标准中未定义           |



## ISR（Interrupt Status Register，中断状态寄存器）

| 位编号（Bit） | 英文缩写 | 功能名称      | 作用说明                                                     |
| ------------- | :------- | :------------ | :----------------------------------------------------------- |
| 0             | IP       | 中断挂起标志  | 1 = 表示当前有未处理的中断；<br />0 = 表示无中断挂起，为总中断状态标识位 |
| 1~2           | -        | 中断标识位    | 编码当前最高优先级中断源：<br />00 = MODEM 状态中断（优先级最低）<br />01 = 发送缓冲区空中断<br />10 = 接收缓冲区满中断<br />11 = 接收线路状态中断（优先级最高），只读属性 |
| 3             | -        | FIFO 状态标志 | 1 = 表示 FIFO 功能已启用；<br />0 = 表示 FIFO 未启用         |
| 4~7           | -        | 保留位        | 固定为 0，无实际意义，仅支持读操作，写入无效                 |



## FCR（FIFO Control Register，FIFO 控制寄存器）

| 位编号（Bit） | 英文缩写 | 功能名称           | 作用说明                                                     |
| :------------ | :------- | :----------------- | :----------------------------------------------------------- |
| 0             | -        | FIFO 总使能        | 1 = 启用收发 FIFO 缓冲区；<br />0 = 禁用 FIFO（回归单字节传输模式）<br />需置 1 后其他 FCR 位才生效 |
| 1             | -        | 清除接收 FIFO      | 写 1 = 清空接收 FIFO 缓冲区并复位接收指针；<br />写 0 = 无操作，写 1 后该位会自动清零 |
| 2             | -        | 清除发送 FIFO      | 写 1 = 清空发送 FIFO 缓冲区并复位发送指针；<br />写 0 = 无操作，写 1 后该位会自动清零 |
| 3             | -        | DMA 模式选择       | 0 = 选择单字节 DMA 模式；<br />1 = 选择块 DMA 模式，用于 UART 与 DMA 控制器协同传输数据 |
| 4~5           | -        | 保留位             | 无实际功能，建议写 0，部分扩展型号 UART 可能用于 DMA 相关扩展控制 |
| 6~7           | -        | 接收 FIFO 触发阈值 | 设定接收 FIFO 触发中断的字节数：<br />00=1 字节、<br />01=4 字节、<br />10=8 字节、<br />11=14 字节，<br />仅 FIFO 启用时有效，用于调整接收中断频率 |

> **UART 的 FIFO 虽是多字节缓冲区，但硬件寄存器层面仍只能单字节读取，“14 字节批量读取” 是软件层面通过循环读取单字节寄存器实现的，而非硬件上一次性读取多字节**。以下是详细的原理和实现方法：
>
> ### 
>
> UART 的 FIFO 本质是一个**硬件队列缓冲区**（16 字节深度，16550 标准），但对外暴露的读取接口依然是**单字节的 RBR（接收缓冲区寄存器）** ——FIFO 的 “多字节” 是 “暂存多字节数据”，而非 “支持多字节读取”：
>
> * 硬件层面：FIFO 内部按 “先进先出” 顺序存储数据，每次仅将队列头部的 1 字节数据放到 RBR 寄存器中；
>
> * 软件层面：读取 1 次 RBR，FIFO 会自动将下 1 字节数据 “补” 到 RBR，直到 FIFO 为空；
>
> * 触发阈值（如 14 字节）的作用：仅控制 “何时触发中断”，而非 “允许一次性读取多少字节”。
>
>   
>
> 简单类比：FIFO 是一个装了 14 个小球的管道，RBR 是管道的出口，每次只能拿出 1 个球，拿完 1 个后下 1 个会自动滚到出口，直到 14 个球都拿完。
