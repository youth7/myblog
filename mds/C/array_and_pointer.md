


指针和数组的关系往往让初学者非常疑惑，它们之间有一些相似性然而又有很多区别，如果仅靠自己写一些demo可能会总结出一些似是而非的答案。其实C的规范中有明确说明两者的关系。在开始讨论之前我们先要了解一些表达式转换的相关知识，这些在C11的6.3.2.1中有明确规定。

# 1 左值（lvalue）、数组和函数指定符（function designator）

## 1.1左值
标准中对左值的定义是：左值是一个**表达式**，它指定（designate）了一个对象（C中的“对象”和面向对象语言中“对象”意思不同，标准3.15对object有定义），这个对象的类型由左值表达式决定。

然而这个说法非常抽象，微软的C文档中对左值的定义则更加易懂：表达式如果表示一个内存地址，则它是一个左值表达式。微软的文档中列出了所有的左值



* 一个整数、浮点数、指针、结构体、联合的标识符
* 一个下标（[]）表达式，并且这个表达式的结果不是指向数组
* 一个成员选择表达式（–> 或者 .）
* 一个星号（*）表达式，并且这个表达式的结果不是指向数组
* 处于括号中的左值
* 一个const对象（这时它属于不可变左值）


既然左值是一个表达式，那么它肯定有值，如果一个左值不是数组类型，且不是作为以下操作符的操作数时
```C
 sizeof
 _Alignof
 &
 ++
 --
 位于.和=的左边（例如struct.name或者int a = 12）
```
此时左值的值就是所指向对象的值，这个过程叫做**左值转换（lvalue conversion）**，例如：

```C
 printf("%d" number);
```
此时number的值就是它所指向的整数的值。


## 1.2 数组
当一个表达式是**数组类型**，且不是用作初始化数组的字符串，不是作为以下操作符的操作数时，
```C
 sizeof
 _Alignof
 & 
```

此时表达式被转换为指向数组的指针，指针类型是**数组元素的类型**，值为首元素的地址。例如：

```C
 printf("%p" array);
 func(array);
```
此时array的值就是它的首元素的地址值。

## 1.3 函数指示符
当一个表达式是函数类型（例如一个表示函数的标识符），且不是作为以下操作符的操作数时
```C
 sizeof
 _Alignof
 & 
```

此时函数指示符被转换为指向函数的指针。

# 2 一个例子和几个问题
给定一个C语言程序以及它对应汇编代码，汇编代码中跟c对应的地方已经给出了注释

```C
#include <stdio.h>

void test(void){
	char array[] ={1,2,3};
	char *p1 = &array[0];
	char (*p2)[3] = &array;
	char *p3 = array;
	p1++;
	p2++;
	p3++;
	printf("%p %p %p %p\n",array, p1, p2, p3 );
}
int main(void){
	test();
	return 0;
}

```

```x86asm  

 push   %rbp
 mov    %rsp,%rbp
 sub    $0x20,%rsp
 movb   $0x1,-0x1b(%rbp);数组第1个元素
 movb   $0x2,-0x1a(%rbp);数组第2个元素
 movb   $0x3,-0x19(%rbp);数组第3个元素
 lea    -0x1b(%rbp),%rax;计算指针p1
 mov    %rax,-0x8(%rbp);p1存到栈中偏移量为0x8个字节的地方
 lea    -0x1b(%rbp),%rax;计算指针p2
 mov    %rax,-0x10(%rbp);p2存到栈中偏移量为0x10个字节的地方
 lea    -0x1b(%rbp),%rax;计算指针p3
 mov    %rax,-0x18(%rbp);p3存到栈中偏移量为0x18个字节的地方
 addq   $0x1,-0x8(%rbp);p1++
 addq   $0x3,-0x10(%rbp);p2++
 addq   $0x1,-0x18(%rbp);p3++
 mov    -0x18(%rbp),%rsi;将p3放到rsi寄存器，给printf函数传参
 mov    -0x10(%rbp),%rcx;将p2放到rcx寄存器，给printf函数传参
 mov    -0x8(%rbp),%rdx; 将p1放到rdx寄存器，给printf函数传参
 lea    -0x1b(%rbp),%rax;计算array的值
 mov    %rsi,%r8;将p3的值拷贝到r8寄存器，给printf函数传参
 mov    %rax,%rsi;将array的值拷贝到rsi寄存器，给printf函数传参
 mov    $0x4005e0,%edi;将格式字符串的地址放到%rdi寄存器，给printf函数传参
 mov    $0x0,%eax
 callq  4003f0 <printf@plt>;
 nop
 leaveq 
 retq 
```

从汇编角度最能看出的区别就是，指针是一个变量，占据存储空间。而数组名仅仅是一个符号，在编译期会被替换为一个地址值，不占据存储空间。

同时引出几个常见的问题：
## 2.1 问：数组跟指针有微妙的关系，可以认为数组名就是指针吗？

答：指针和数组是C中两种完全不同类型的元素，具有截然不同的语义。数组代表一系列连续的、类型相同的对象，指针则是一个存储某个对象地址的整型。让人产生“数组就是指针”这种错觉有两个原因：

* 首先是在上述的1.2所述下，**数组会被转换为指针**。我们可以将数组赋值给指针（例如`*p = a`）, 或者将像指针一样使用数组（例如：`*(a+1)=64`），这样的表达式让人觉得它们“相同”。

* 其次是**指针也能像数组一样使用下标运算符进行元素的访问**，p[n]这样的表达式让人觉得指针似乎也是数组。其实根据C11的6.5.2.1，E1[E2] 是等价于 (*((E1)+(E2)))，E1、E2其中之一是整数，另一则是指针或者数组。这个规则只能说明数组和指针恰好具有某个相同的特性。如果凭借这个就能断言数组就是指针，那么我也能得出谬论：整数n等同于数组/指针，因为根据规范E[n] 和 n[E]是等价的。

在《C专家编程》4.3.2上还举出了一个数组跟指针完全不同的例子
假设有文件test.c
```C
int a[3] = {66, 77, 88};
int * getRealAddress() {
	return &a[0];
}
```
然后在文件main.c中引用了a
```C
#include<stdio.h>
int main(void) {
	extern int * a;//注意，这里和test.c中声明不一致
	extern int * getRealAddress();
	printf("%d %p %p\n", a, getRealAddress(), &a);
	return 0;
}
```
然后手动编译、链接然后执行

```BASH
gcc -c test.c 
ar -rc liballfiles.a test.o
gcc main.c -L. -lallfiles -o out 
./out
```

在我的机器上（Fedora26 + GCC7）输出的结果是：
```BASH
66 0x601028
```
我们一开始潜意识会认为，数组跟指针是一回事，因此main.c中的`a[0]`应该是66，和test.c中一样，也即意味着
`a`的值和`&a[0]`相同，然而并非如此，如果直接使用`a[0]`，则会出现一个段错误，因为访问了不允许访问的内存空间，其根本原因如下：

* 首先先要理解指针的取值方式。对于上述的指针`a`，它首先是一个存在于内存中的变量，它的值是另一个变量的内存地址。当要获取指针`a`的值的时候，程序首先要知道`a`是保存在哪一个内存地址中（即`a`自己的内存地址）。但是`a`的声明方式是`extern int * a`。这告诉编译器，`a`虽然是一个指针，但是它的定义是在另外一个文件中，因此编译时期我们**不知道`a`的地址，因此也不知道`a`的值**，等链接时候再修正。


* 然后要理解链接过程中链接程序会自动修正相关变量
我们先用命令`objdump -d  out`看看链接好之后的程序，截取main函数部分
```x86asm
00000000004004d7 <main>:
  4004d7:	55                   	push   %rbp
  4004d8:	48 89 e5             	mov    %rsp,%rbp
  4004db:	b8 00 00 00 00       	mov    $0x0,%eax
  4004e0:	e8 23 00 00 00       	callq  400508 <getRealAddress>
  4004e5:	48 89 c2             	mov    %rax,%rdx
  4004e8:	48 8b 05 39 0b 20 00 	mov    0x200b39(%rip),%rax        # 601028 <a>
  4004ef:	48 89 c6             	mov    %rax,%rsi
  4004f2:	bf b0 05 40 00       	mov    $0x4005b0,%edi
  4004f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4004fc:	e8 ef fe ff ff       	callq  4003f0 <printf@plt>
  400501:	b8 00 00 00 00       	mov    $0x0,%eax
  400506:	5d                   	pop    %rbp
  400507:	c3                   	retq 

```
地址为4004e8处的汇编代码是程序根据`a`的内存地址去获取`a`的值，它表明了`a`自己的内存地址是0x200b39 + 保存于rip寄存器的值（即0x4004ef），即`a`的最终地址为0x4004ef + 0x200b39 = 0x601028。**至此我们终于取得了`a`自己的内存地址**。

内存中0x601028这里存的值就是`a`的值，我们用gdb看一下

```BASH
(gdb) print /x  $rip + 0x200b39
$3 = 0x601028
(gdb) x /3dw 0x601028
0x601028 <a>:	66	77	88
```
可以看到内存中从0x601028这里开始，保存了3个整数，就是我们在test.c中定义的数组的值。接着程序会从0x601028处开始读取4个字节（在默认情况下）作为a的值，即66，**至此我们得知a的意义是指向内存地址为66的地方**。因此`a[0]`就是在地址为66的地方读取一个整数，很明显这是错误的，66被当做地址处理了。发生这个错误的根本原因在于指针的工作方式，指针本身也是一个变量，要读取指针所指向的对象的值要分为两步，首先是知道指针自己的地址，然后从中读出指针的值，然后根据这个值，再从内存中读出指定对象的值。


总之数组和指针是指代意义完全不同的两种元素，假设T代表某种数据类型，则一维数组的类型是T[n]，指针的类型则是T *。在语义的抽象层面上，如果两个变量具有不同的类型，则它们不属于同一类事物，就像`int` 和 `struct`一样，没有人会说`int`就是`struct`。





## 2.2 问：上述代码中`array`、`&array`和`&array[0]`三者之间有什么联系？（未完成）

答：三者的值相同，都是数组首元素的地址，区别在于：
* 根据1.2所述，`array`此时被转换为指针，类型是`char *`
* `&array`是类型为`char (*)[3]`的指针，即指向数组的指针，它用作计算时候伸缩的粒度是数组的长度，从汇编中可以证实这点，`p2++`的粒度是3，而`p1`和p3是1。
* `&array[0]`非常容易理解，就是`char *`类型的指针（注意它的类型和`&array`不同，和`array`相同）。

需要注意的是，根据6.5.6/8，对于表达式`(&array + n)`，当n>1的时候，这个表达式的行为是未定义的，[这里](https://www.zhihu.com/question/24195849)有一个相关的讨论


有兴趣可以看看stackoverflow上面的[这篇文章](https://stackoverflow.com/questions/4607128/in-c-are-arrays-pointers-or-used-as-pointers)，非常详细介绍了指针和数组的关系，同时还扩展到了多维维数组