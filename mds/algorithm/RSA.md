本文将讨论以下内容
* 一些与RSA算法相关的基本数学概念
    * 互质
    * 算术基本定理
    * 欧拉函数
    * 欧拉定理
    * 模反元素
    * 一些后续证明会用到的数学结论    
* 如何生成公钥、私钥
* 公钥秘钥为何难以破解
* 如何利用公钥、私钥进行加密、解密
* 解密过程的数学证明

建议初次阅读不要纠结欧拉公式和欧拉定理的相关证明（具体证明可以在参考资料中找到），要将精力放在公钥秘钥的生成以及如何使用公钥秘钥进行加密解密。（不过我个人最感兴趣的是解密过程的数学证明，因此还是补全了那个证明）

## 一些与RSA算法相关的基本数学概念
### 互质
如果两个整数除了1之外没有其它公约数，则称这两个数互质（比如7、15互质，8、9也是互质，注意一个数即使不是质数，也有可能和另外一个数互质）。
基于互质的性质，我们有以下推论：

* 任意两个质数互质，比如13和61。
* 一个数是质数，另一个数只要不是前者的倍数，则两者互质，比如3和10。
* 如果两个数之中，较大的那个数是质数，则两者互质，比如97和57。
* 1和任意自然数互质，比如1和99。
* p是大于1的整数，则p和p-1互质，比如57和56。
* p是大于1的奇数，则p和p-2互质，比如17和15。

### 算术基本定理
任何一个大于$1$的自然数 $n$,如果$n$不为质数，那么$n$可以唯一分解成有限个质数的乘积。例如 $n = 15 = 3 \times 5$，其中$3$和$5$称为**质因数**。

### 欧拉函数
欧拉函数解决了以下问题：
> 给定一个正整数$n$，求出小于等于$n$的正整数中，有多少个和n构成互质？例如当$n=8$时，整数$1、3、5、7$和$8$都是互质，因此答案是$4$。

这个问题的通解是欧拉函数，即

$\begin{equation}
\begin{aligned}
φ(n) & = p^{k1}_1p^{k2}_2...p^{kn}_n (1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_n}) \\
& = n(1-\frac{1}{p_2})...(1-\frac{1}{p_n})
\end{aligned}
\end{equation}$

其中 $p^{k1}_1p^{k2}_2...p^{kn}_n$是$n$的所有**不同的质因数**。特别地，当$k_1=k_2=...k_n=1$时，欧拉公式可以写成  

$φ(n)  = p_1p_2...p_n (1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_n})$


由算术基本定理可知$n$可以分解为若干个质因数的乘积，但是欧拉公式**只取不同的质因数**。
例如$8 = 2 * 2 * 2$，虽然$8$由三个质因数相乘组成，但是不同的质因数只有1个（即$2$），因此$φ(8) = 8*(1-\frac{1}{2})=4$，同理$φ(5) = 5*(1-\frac{1}{5})=4$



### 欧拉定理
若$n,a$为正整数，且$n,a$互质，则等式$a^{φ(n)} \equiv 1 \pmod n$成立。意思是：如果$a$和$n$互质，则$a$的$φ(n)$次方除以$n$，余数为$1$。欧拉定理是证明RSA解密可行的关键
> 注意：初次阅读不要纠结欧拉函数和欧拉定理的证明，你可以回头再查看相关资料，但目前你只需要记住这个结论。我们需要先掌握RSA的整体，再看其中各个细节。

### 模反元素（又叫做模逆元）
如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得 $ab-1$ 被$n$整除，或者说$ab$被$n$除的余数是$1$。即  
$ab \equiv 1 \pmod n$  
证明：    
> 由欧拉定理有  
$a^{φ(n)} =  \equiv 1 \pmod n$
而  
$a^{φ(n)} = a a^{φ(n)-1}$  
所以$b=a^{φ(n)-1}$

### 一些后续证明会用到的数学结论
* 如果$a \bmod b = 1$，则$ka \bmod b = k \bmod b$   
    这个结论非常容易理解，如果$a$除以$b$余数为$1$，则多个$a$除以$b$的余数会一直累积。例如  
    $10 \bmod 3 =1$  
    $20 \bmod 3 =1$  
    $30 \bmod 3 =0$

* 如果$a \bmod b = 1$，则$a^k \bmod b = 1$    
    证明：  
    > 由条件可得$a = bm + 1$ ①  
    要证$a^k \bmod b = 1$，即证$a^k = bn + 1$  
    由①式可得  
    $a^n = (bm + 1)^n$，  
    根据二项式定理展开整理最终可得  
    $a^n = bk + 1$，$k=b(c^0_nb^{n-1}m^n + c^1_nb^{n-2}m^{n-1}  ... +  c^{n-1}_nb^{-1}m^{0})$

* 朴素欧几里德算法  
    $gcd(a, b) = gcd(b, a \bmod b)$  
    这个算法可以用来求出两个整数$a$和$b$的最大公约数gcd（greatest common divisor）。例如求10和4的最大公约数，用程序表示就是
    ```js
     function gcd(a, b){//不妨令a>b>0
         if(b==0){
             return a;
         }else{
             return gcd(b, a%b)
         }
     }
    //gcd(10,4)返回2， 因此10和4的最大公约数就是2
    ```

* 扩展欧几里德算法      
    对于不全为 0 的非负整数 $a、b$（假设$a>b$），$gcd(a, b)$表示 $a、b$ 的最大公约数，必然存在整数对 $x、y$ ，使得 $gcd(a, b)=ax+by$。$x、y$的求解推导可以看[这里](https://www.zybuluo.com/samzhang/note/541890#exgcd)。  
    其实，方程$gcd(a, b)=ax+by$的解不是唯一的，通过扩展欧几里德算法只是求得了其中一组解，可以通过这组解进而推导出方程的通解。在RSA算法中，一般取$x$为最小整数的那组解。 而$x$的通解公式为$x = x_0 + kb$ ，其中$x_0$是方程已经求得的一个解。取$k=⌈ -\frac{x_0}{b} ⌉$，就可求得$x$的最小正整数解。用程序描述就是 

   ```js
    function extendEuclidean(a, b) {
        if (b === 0) {
            return {
                x: 1,
                y: 0
            };
        }
        const { x, y } = extendEuclidean(b, a % b);
        return {
            x: y,
            y: x - Math.floor(a / b) * y
        };
    }
    function getMin(a, b) {//求出最小的整数解
        const { x, y } = extendEuclidean(a, b);
        console.log(x,y);
        const k =  Math.ceil(- x/b);
        const minX = x + k*b;
        const minY = (a * minX - 1) / b;
        return {
            x: minX,
            y: minY
        };
    }
    (function() {
        const [n, e, d] = [323, 13, 133];
        for (let i = 0; i < n; i++) {
            let text = i;
            const ciphertext = BigInt(i) ** BigInt(e) % BigInt(n);
            console.log("密文为", ciphertext);
            const decrypt = BigInt(ciphertext) ** BigInt(d) % BigInt(n);
            console.log("明文为", Number(decrypt), text);
        }
    })();
   ```
 
    例如：令$a=17$，$b=3120$来调用函数`extendEuclidean(17, 3120)`，则会得到一组解$x=-367, y=2$，但是我们需要的是$x$为最小正整数的那组解。通过调用`getMin(17, 3120)`我们可以得到$x=-2753, y=-15$

    特别地，当$a、b$互质时有$ax+by=1$，这个方程当然也可以使用扩展欧几里德算法求解，这个工具在RSA中计算模反元素$d$时会用到。


## 如何生成公钥、私钥
### 第1步  
任意选择两个不相等的质数$p$和$q$，并计算出以下两个值
* $n=p \times q$
* $φ(n) = (p-1)(q-1)$  

例如我们这里选择$p=79,q=113$，则容易算出$n=8927, φ(n) =8736$

### 第2步
随机选择一个整数$e$（这里的$e$是单词exponent的首字母，因为$e$在后续的加密解密中会用作指数），使得$1< e < φ(n)$，**且$e$与$φ(n)$互质**。例如这里选择$e=53$

### 第3步
计算$e$对于$φ(n)$的模反元素$d$（不知道为何网上关于模反元素的描述都是用$d$来表示）  
$ed \equiv 1 \pmod {φ(n)}$  
即有  
$ed - k φ(n) = 1$，即$ed + φ(n)(-k) = 1$  
将$e=53、φ(n)=8736$代入上式得    
$53d + 8736(-k) = 1$，令$d=x，-k=y$则有  
$53x + 8736y = 1$
看到这个形式，马上就能联想到上面说过的扩展欧几里德算法，调用函数`getMin(53, 8736)`，可以求得$d=x=989$，则  
* 公钥=$(n,e)=(8927, 53)$  
* 私钥=$(n,d)=(8927,989)$


## 公钥秘钥为何难以破解

公钥是公开的，所有人都可以获取，发送方用公钥加密明文然后发给接收方，接收方使用私钥进行解密。一个攻击者想要窥视通讯内容，就必须截获密文并且破解之。**而破解密文的关键就是私钥中的$d$**（私钥中的$n$已经包含在公钥中，因此是已知的）。$d$是从方程：  
$$ed + φ(n)(-k) = 1$$  
中算出，因为$e$是已知的（包含在公钥中），因此问题转化为求$φ(n)$，而  
$$φ(n) = pq(1-\frac{1}{p})(1-\frac{1}{q}) = (p-1)(q-1)$$   
因此问题转化为求$p,q$，而   
$$n = pq$$
因为$n$是已知的，因此问题最终转化为这个数学问题  
> 已知$n$是两个质数$p, q$的乘积，求$p$和$q$

分解质因数是困难的，目前尚没有有效的从$n$反推出$p、q$的算法，因此RSA的坚固性是基于这个困难的数学问题。  
有一种攻击的想法是：既然无法直接反推出$pq$，可不可以把一定范围内的素数全部找出来，再任意选中两个相乘得到结果$n$，然后把$n$储存起来，破解时候直接查表就可以得出$pq$了。这个思路不现实的地方在于，对于一个2046位的二进制数字，它的取值范围是$[0, 2^{2045}]$，而$2^{2045}\approx 4 \times 10^{615}$。这个数字好像也不是很大？如果你知道整个宇宙的原子总数大概为$10^{80}$，应该就不会这样想了。因此计算所有$pq$的乘积是不靠谱的，因为某个范围内的质数实在是太多了（即使质数在数轴上并不是均匀分布，但是在这么大的基数下最终数量也是非常大的）。




## 如何利用公钥、私钥进行加密、解密
### 加密公式
$密文 =  明文^e \bmod n$
>注意：由数论知识可以知道，$m \bmod n$的值域是$[0, n)$，因此明文的值域不能超过密文的值域，否则会产生碰撞。**同时这也意味着$m < n$，记住这个结论，等下证明会用到**  

现在假设我的明文是$1234$，则根据上述公式可得：密文$=1234^{53} \bmod 8927 = 483$

### 解密公式
$明文 = 密文^d \bmod n$  

将上式的密文=$483$代入，可求得明文$=483^{989} \bmod 8927 = 1234$

上述过程涉及超大整数计算，可以使用python或者这个[在线网站](http://www.wolframalpha.com/input/?i=(483%5E989)+mod+8927)进行计算

## 解密过程的数学证明
为方便讨论，将上面的加密解密公式写成标准数学公式：
* 加密：$m^e ≡  c \pmod n$
* 解密：$c^d ≡  m \pmod n$ 

现在需要证明解密公式是一定成立。由加密公式可得  
$c = m^e - kn$  
将它代入解密公式有  
$(m^e - kn)^d ≡ m \pmod n$  
它等价于  
$m^{ed} ≡ m \pmod n$②
>这是因为：使用二项式将$(m^e - kn)^d$展开，则除了第一项外其它项都包含$kn$，都可以被$n$整除 

因为
$ed ≡ 1 \pmod {φ(n)}$
> RSA计算的第3步

所以  
$ed = hφ(n) +1$
>注意这个公式，等下回用到

将$ed$代入②式得  
$m^{hφ(n) +1} ≡ m \pmod n$  ③  
则问题转化为证明式子③，我们将分两种情况对这个式子进行证明

### 情况1：当$m$、$n$互质时  
根据欧拉定理有  
$m^{φ(n)}≡1 \pmod n$  
由上述的第二点数学结论可得  
$(m^{φ(n)})^h≡1 \pmod n$  
再由上述的第一点数学结论可得  
$(m^{φ(n)})^h \times m ≡m \pmod n$  

所以③得证。

### 情况2：当$m$、$n$不互质时 
因为$m$、$n$不互质，且$n = pq$，则必定有$m=kp$或者$m=kq$，不妨设$m=kp$。  
因为$q$是质数，所以$k、q$互质（$q$不可能是$k$质因数，因为若$k=lq$的话，则$m = kp = lqp = ln > n$，这与上面说的$m < n$矛盾），即$m、q$互质  
根据欧拉定理有  
$(m)^{φ(q)} ≡ 1 \pmod q$  
即  
$(kp)^{q-1} ≡ 1 \pmod q$   
根据上述的数学结论1和2可得  
$[(kp)^{q-1}]^{h(p-1)} × kp ≡ kp \pmod q$
即  
$(kp)^{h(q-1)(p-1)+1}  ≡ kp \pmod q$  
将上面的公式$ed = hφ(n) +1$代入有  
$(kp)^{ed}  ≡ kp \pmod q$  
即  
$(kp)^{ed} = tq + kp$  
这时$t$必然能被$p$整除，即有$t=t'p$
> 这是因为上式两边同时除以$p$，可知等式左边必然能够整除，因此右边$t \frac{q}{p} + p$也必然是一个整数。又因为$pq$互质，则$\frac{t}{p}$必然是一个整数，这样才能保证等式成立。  

因此上式可写为  
$(kp)^{ed} = t'pq + kp$   
将$m=kp$、$n=pq$代入得  
$m^{ed} = t'n + m$   
即  
$m^{ed} ≡ m \pmod n$   
因此③式得证








<!-- ①②③④⑤⑥⑦⑧⑨⑩ -->

参考资料
[http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)