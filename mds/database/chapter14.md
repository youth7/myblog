
# 事务的隔离性
## 一些基本概念

> **提示**：可以将事务看成一个线程，多个事务就是多线程，事务的并发相当于多线程并发。当多线程并发修改同一个变量时候，如果没有同步机制，则数据会出现不一致，数据库所谓的脏读、幻影读之类也是类似。线程对变量的加锁级别类似于事务的隔离级别。  

> 同时，通篇在谈论调度是否可串行化，判断的根本标准在于指令之间是否存在相关性（有点类似CSAPP关于性能优化那一章的内容），如果不同指令在操作同一个数据，则指令之间是相关的，相关的话就有先后顺序，因此不能改变它们的先后顺序。如果指令之间不操作同一个数据，则没有相关性，可以调整它们之间的顺序。调整指令的顺序是为了达到并发，使得db有更好的吞吐量。   

> 注意指令之间调整顺序，是指不同事务的指令之间，同一个事务之间是否可以调整指令顺序，书上没有提及，不过根据CSAPP的理论，个人认为如果不存在指令相关性，则同一个事务内的指令也是可以可以调整顺序的，类似于并发时候的乱序执行

* 调度：一组事务包含m个事务，一个事务包含n个指令，则一组事务总共包含i = n*m个指令。一个调度（schedule）则表示这个i个指令的执行顺序。
* 串行调度：事务之间的指令不会交叉执行，即一个事务的指令全部执行完毕之后，再轮到下一个事务。
* 可串行化：如果一个调度（即使它不是串行调度，即事务之间的指令是交错执行）等价于一个串行调度，则这种调度称为可串行化（serializable）调度。

## 可串行化
* 冲突：  
    设i、j分别是事务T1、T2的 **两条连续的指令（注意i、j必须是连续的，意味着它们紧挨着，中间没有任务指令）** ，**不同事务对同一数据项的操作**，当i、j至少有1个为write指令时，我们称i、j是冲突的。只有i、j都为read指令时候才没有冲突。
* 冲突等价（对于两个调度来说）：  
    调度S经过一系列非冲突指令交换得到调度 **S'**，则称S和 **S'** 是冲突等价的
* 冲突可串行化：  
    若一个调度S与一个串行调度*冲突等价*，则称S是*冲突可串行化*。（一个调度的冲突如果无法串行化，很有可能会导致不一致？，例如事务T1读了数据，然后事务T2写了数据，此时T1的后续操作都是基于过时的数据，必然会导致不一致，有多种策略来防止不一致性，15章会详细说明）

## 通过优先图来判断调度S是否冲突可串行化  
如果T1、T2操作同一个数据Q，且符合以下条件之一，产生T2指向T1的边
* T2在“读”之前，T1发生了“写”  
* T2在“写”之前，T1发生了“读”
* T2在“写”之前，T1发生了“写”


如果优先图无环，则调度S是*冲突可串行化*，否则S非*冲突可串行化*。优先图的箭头意味着一种依赖关系，想要保证一致性必须要等待**箭头指向的事务完成对资源的操作**。出现环形即意味着，事务T1尚未结束对资源的使用，事务T2就中途插了进来。如图  
![db_c14.jpg](/imgs/db_c14.jpg)

其核心思想是：**事务在没有结束的过程中，它所使用的资源不应该被其它事务使用**。


## 隔离级别
|隔离级别 |   脏 读|   不可重复读|   幻 读|
| - | -  | -  |-|
| 读未提交 |    |    | |
| 读已提交 | 避免  |    | |
| 可重复读 | 避免  | 避免  | |
| 串行化 | 避免  | 避免  |避免|
 
