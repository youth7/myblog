本文将讨论以下内容
* 一些与RSA算法相关的基本数学概念
    * 互质
    * 算术基本定理
    * 欧拉函数
    * 欧拉定理
    * 模反元素
    * 一些后续证明会用到的数学结论    
* 如何生成公钥、私钥
* 公钥秘钥为何难以破解
* 如何利用公钥、私钥进行加密、解密
* 解密过程的数学证明

建议初次阅读不要纠结欧拉公式和欧拉定理的相关证明（具体证明可以在参考资料中找到），要将精力放在公钥秘钥的生成以及如何使用公钥秘钥进行加密解密。（不过我个人最感兴趣的是解密过程的数学证明，因此还是补全了那个证明）

## 一些与RSA算法相关的基本数学概念
### 互质
如果两个整数除了1之外没有其它公约数，则称这两个数互质（比如7、15互质，8、9也是互质，注意一个数即使不是质数，也有可能和另外一个数互质）。
基于互质的性质，我们有以下推论：

* 任意两个质数互质，比如13和61。
* 一个数是质数，另一个数只要不是前者的倍数，则两者互质，比如3和10。
* 如果两个数之中，较大的那个数是质数，则两者互质，比如97和57。
* 1和任意自然数互质，比如1和99。
* p是大于1的整数，则p和p-1互质，比如57和56。
* p是大于1的奇数，则p和p-2互质，比如17和15。

### 算术基本定理
任何一个大于1的自然数 $n$,如果$n$不为质数，那么$n$可以唯一分解成有限个质数的乘积。例如 $n = 15 = 3 * 5$，其中3和5称为**质因数**。

### 欧拉函数
欧拉函数解决了以下问题：
> 给定一个正整数n，求出小于等于n的正整数中，有多少个和n构成互质？例如当n=8时，整数1、3、5、7和8都是互质，因此答案是4。

这个问题的通解是欧拉函数，即

$\begin{equation}
\begin{aligned}
φ(n) & = p^{k1}_1p^{k2}_2...p^{kn}_n (1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_n}) \\
& = n(1-\frac{1}{p_2})...(1-\frac{1}{p_n})
\end{aligned}
\end{equation}$

其中 $p^{k1}_1p^{k2}_2...p^{kn}_n$是$n$的所有**不同的质因数**。特别地，当$k_n=1$时，欧拉公式可以写成  

$φ(n)  = p_1p_2...p_n (1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_n})$


由算术基本定理可知$n$可以分解为若干个质因数的乘积，但是欧拉公式**只取不同的质因数**。
例如$8 = 2 * 2 * 2$，虽然8由三个质因数相乘组成，但是不同的质因数只有1个（即$2$），因此$φ(8) = 8*(1-\frac{1}{2})=4$，同理$φ(5) = 5*(1-\frac{1}{5})=4$



### 欧拉定理
若$n,a$为正整数，且$n,a$互质，则等式$a^{φ(n)} \equiv 1 (\mod n)$成立。意思是：如果$a$和$n$互质，则$a$的$φ(n)$次方除以$n$，余数为$1$。欧拉定理是证明RSA解密可行的关键
> 注意：初次阅读不要纠结欧拉函数和欧拉定理的证明，你可以回头再查看相关资料，但目前你只需要记住这个结论。

### 模反元素（又叫做模逆元）
如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得 $ab-1$ 被$n$整除，或者说$ab$被$n$除的余数是$1$。，即  
$ab \equiv 1 (\mod n)$
由欧拉定理有$a^{φ(n)} = a a^{φ(n)-1} \equiv 1 (\mod n)$，因此可知$b=a^{φ(n)-1}$

### 一些后续证明会用到的数学结论
* 如果$a \mod b = 1$，则$ka \mod b = k \mod b$   
    这个结论非常容易理解，如果$a$除以$b$余数为$1$，则多个$a$除以$b$的余数会一直累积

* 如果$a \mod b = 1$，则$a^k \mod b = 1$    
    证明：  
    由条件可得$a = bm + 1$ ①  
    要证$a^k \mod b = 1$，即证$a^k = bn + 1$  
    由①式可得$a^n = (bm + 1)^n$，根据二项式定理展开整理最终可得$a^n = bk + 1$，$k=b(c^0_nb^{n-1}m^n + c^1_nb^{n-2}m^{n-1}  ... +  c^{n-1}_nb^{0}m^{1})$

* 朴素欧几里德算法  
    $gcd(a, b) = gcd(b, a \mod b)$  
    这个算法可以用来求出两个整数a和b的最大公约数gcd（greatest common divisor）。例如求10和4的最大公约数，用程序表示就是
    ```js
     function gcd(a, b){//不妨令a>b>0
         if(b==0){
             return a;
         }else{
             return gcd(b, a%b)
         }
     }
    //gcd(10,4)返回2， 因此10和4的最大公约数就是2
    ```

* 扩展欧几里德算法      
    对于不全为 0 的非负整数 $a、b$（假设$a>b$），$gcd(a, b)$表示 $a、b$ 的最大公约数，必然存在整数对 $x、y$ ，使得 $gcd(a, b)=ax+by$。$x、y$的求解推导可以看[这里](https://www.zybuluo.com/samzhang/note/541890#exgcd)。  
    其实，方程$gcd(a, b)=ax+by$的解不是唯一的，通过扩展欧几里德算法只是求得了其中一组解，可以通过这组解进而推导出方程的通解。在RSA算法中，一般取$x$为最小整数的那组解。 而$x$的通解公式为$x = x_0 + kb$ ，其中$x_0$是方程已经求得的一个解。取$k=⌈ -\frac{x_0}{b} ⌉$，就可求得$x$的最小正整数解。用程序描述就是 

   ```js
    function extendEuclidean(a, b) {
        if (b === 0) {
            return {
                x: 1,
                y: 0
            };
        }
        const { x, y } = extendEuclidean(b, a % b);
        return {
            x: y,
            y: x - Math.floor(a / b) * y
        };
    }
    function getMin(a, b) {//求出最小的整数解
        const { x, y } = extendEuclidean(a, b);
        console.log(x,y);
        const k =  Math.ceil(- x/b);
        const minX = x + k*b;
        const minY = (a * minX - 1) / b;
        return {
            x: minX,
            y: minY
        };
    }
    (function() {
        const [n, e, d] = [323, 13, 133];
        for (let i = 0; i < n; i++) {
            let text = i;
            const ciphertext = BigInt(i) ** BigInt(e) % BigInt(n);
            console.log("密文为", ciphertext);
            const decrypt = BigInt(ciphertext) ** BigInt(d) % BigInt(n);
            console.log("明文为", Number(decrypt), text);
        }
    })();
   ```
 
    调用函数`extendEuclidean(17, 3120)`，则会得到一组解`x=-367, y=2`。而`x=2753, y=-15`是方程组的另一组解（通过`getMin(17, 3120)求得`），这组解的$x$是所有解中最小的。

    特别地，当$a、b$互质时有$ax+by=1$，这个方程当然也可以使用扩展欧几里德算法求解，这个工具我们等下回用到。


## 如何生成公钥、私钥
### 第1步  
任意选择两个不相等的质数$p$和$q$，并计算出以下两个值
* $n=p \times q$
* $φ(n) = (p-1)(q-1)$  

例如我们这里选择$p=79,q=113$，则容易算出$n=8927, φ(n) =8736$

### 第2步
随机选择一个整数$e$（这里的$e$是单词exponent的首字母，因为$e$在后续的加密解密中会用作指数），使得$1< e < φ(n)$，**且$e$与$φ(n)$互质**。例如这里选择$e=53$

### 第3步
计算$e$对于$φ(n)$的模反元素$d$（不知道为何网上关于模反元素的描述都是用$d$来表示）  
$ed \equiv 1 (\mod φ(n))$  
即有  
$ed - k φ(n) = 1$，即$ed + φ(n)(-k) = 1$  
将$e=53、φ(n)=8736$代入上式得    
$53d + 8736(-k) = 1$，令$d=x，-k=y$则有  
$53x + 8736y = 1$
看到这个形式，马上就能联想到上面说过的扩展欧几里德算法，调用函数`getMin(53, 8736)`，可以求得$d=x=989$，则公钥就是$(n,e)=(8927, 53)，私钥是(n,d)=(8927,989)$


## 公钥秘钥为何难以破解
由上可知：
* 公钥 = $(n, e)$  
* 私钥 = $(n, d)$  

其中公钥是公开的，所有人都可以获取，发送方用公钥加密明文然后发给接收方，接收方使用私钥进行解密。一个攻击者想要窥视通讯内容，就必须截获密文并且破解之。而破解的关键就是私钥用的$d$。$d$是从方程：  
$ed + φ(n)(-k) = 1$  
中算出，因为$e$已知，因此问题转化为求$φ(n)$，而  
$φ(n) = (p-1)(q-1)$   
因此问题转化为求$p,q$，而 
$n = pq$  
因为$n$是已知的，因此问题转化为这个数学问题  
> 已知$n$是两个两个质数$p, q$的乘积，求$p$和$q$






## 如何利用公钥、私钥进行加密、解密
### 加密公式
$密文 =  明文^e \mod n$
>注意：由数论知识可以知道，$m \mod n$的值域是$[1, n)$，因此明文的值域不能超过密文的值域，否则会产生碰撞  

现在假设我的明文是1234，则根据上述公式可得密文$=1234^{53} \mod 8927 = 483$

### 解密公式
$明文 = 密文^m \mod n$  

将上式的密文=483代入，可求得明文$=483^{989} \mod 8927 = 1234$

上述过程涉及超大整数计算，可以使用python或者这个[在线网站](http://www.wolframalpha.com/input/?i=(483%5E989)+mod+8927)进行计算

## 解密过程的数学证明

参考资料
