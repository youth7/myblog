# 静态链接和动态链接

本文在Linux环境下进行阐述，并假设用户将源码编译为可执行文件。

## 静态链接（链接时重定位）

静态链接的思路很简洁，归纳起来是两点：

1. 首先，源码编译为目标文件(.o文件)时，程序中不确定的符号地址全部预留空白，留待链接时再解析出具体值。

2. 然后，将目标文件和静态链接库（.a文件）链接为一个可执行文件，可执行文件**包含它所依赖的全部内容**。在此过程中需要解决步骤1未完成的符号地址解析工作。

与动态链接不同的是，它在是在**链接时**完成符号解析工作。而动态链接则是**加载时**完成符号解析工作，因为动态链接**在链接时并不知道所依赖的共享对象会加载到程序虚拟地址空间的具体位置**，因此无法做符号解析。但静态链接则没有这个问题，因为静态链接会将.a文件的内容也整合到最终的可执行文件当中。



下面介绍一下静态链接在RISC-V下的具体过程：TODO







## 动态链接（运行时重定位）

动态链接的思路是这样的：

1. TODO

2. TODO



### 动态链接库如何映射到程序的虚拟地址空间

其中最关键的一点是共享对象的装载方式，即共享对象如何映射到目标程序的地址空间，有以下几种思路

* 固定地址装载

  把共享对象(.so文件)装载到目标程序地址空间的固定的地址，例如规定*lib1.so*装载到地址空间*a1*，*lib2.so*装载到地址空间*a2*......如此类推。因为所有动态链接库的地址都是规定好的，那链接时解析符号的具体地址也不难了。

  显然这是一种局限性非常大的方法，至少有以下缺陷：

  * 地址冲突：不同的开发团体采用不同的映射规则，难以统一以致冲突。
  * 地址浪费：因为共享对象只能加载到固定的地址，所以即使程序没有用到某个共享对象，也不能使用这个地址。
  * 升级：一旦升级了共享对象导致加载的地址产生变化，则需要将目标程序重新链接。这个问题非常严重，如果不解决则一旦某个共享对象升级了，所有依赖它的目标文件都需要重新链接，这是不能接受的。

  TODO：搜索静态链接库内容 

* 基址重置（装载时重定位）

* 地址无关代码（PIC） 
  * 模块内
    * 通过获取当前PC值来实现相对地址访问
  * 模块间
    * GOT
    * PLT



