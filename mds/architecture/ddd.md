# 序言

* 软件之所以很复杂、难以维护，根本原因就在于**软件的概念完整性遭到了破坏，甚至开发团队的成员从来就没有意识到有必要去维护软件的概念完整性**，他们并不是一个真正的团队，只是一些自行其事的开发人员，碰巧在一个团队中一起堆代码而已。  
* DDD 就是目前维护软件项目“概念完整性”的最佳良药。
* 重构是在代码实现层面对抗腐烂变质，而 DDD 是在代码架构设计层面对抗腐烂变质。 
* DDD 其实没有什么太多的新鲜玩意，它更多地是可以看作是面向对象思潮的回归和升华。在一个“万事万物皆对象”的世界里，哪些对象是对我们的系统有用的？哪些是对我们拟建系统没有用处的？我们应该如何保证我们选取的模型对象恰好够用？  

# 何为DDD

# 创建通用语言

* 基于UML
* 创建若干个小图，每个小图包含了模型的一个子集



# 模型驱动设计

* **拥有一个在分析层面正确的模型，并不代表模型能被直接表达成代码。或者它的实现会违背某些
  软件设计原则，这是我们不建议做的事情**。选择一个能够被轻易和准确地转换成代码的
  模型是很重要的。根本的问题是：我们应该如何完成从模型到代码的转换  

* 分析模型
  * 分析模型是业务领域分析的结果，此模型不需要考虑软件如何实现。这样的一个模型可用来理解领域，它建立了特定级别的知识，模型在分析层面是正确的 。
  * 这个模型到达开发人员那里后，由他们来做设计的工作。因为这个模型中没有包含设计原则，它可能无法很好地为目标服务。因此开发人员不得不修改它，或者创建分离的设计。**在模型和代码之间也不再存在映射关系。最终的结果是分析模型在编码开始后就被抛弃了**  
* 模型在构建时就考虑到软件实现和设计。开发人员应该被加入到建模的过程中来。主要的想法是**选择一个能够在软件实现中恰当地表达的模型，这样设计过程会很顺畅并且基于模型**。  
*   设计软件系统的一部分，确保它能如实反映领域模型，让（设计与模型之间的）映射显而易见。
* 面向对象编程语言使得在带有关联关系的模型对象与它们的编程对等物之间创建直接的映射成为了可能。  
*   某些特殊的领域（例如数学）可以使用过程化编程来轻易地建模和实现，那是因为很多数学理论大多数都是关于计算的，可以简单地使用函数调用和数据结构来解决。更加复杂的领域并非仅仅是一组包含有计算的一套抽象的概念，无法被简化成一系列的算法，因此过程化语言不足以表达相应的模型。因为这个原因，对于模型驱动设计而言，不推荐使用过程化编程。  

## 模型驱动设计的基本构成要素  

本章接下来的几节中会展现在模型驱动设计中要使用的最重要的模式。这些模式的作用是**从领域驱动设计的角度展现一些对象建模和软件设计中的关键元素**。

> 意思即介绍DDD中一些基础的概念，基于这些概念来进行基于领域模型的分析和设计，以下所说的概念**都是模型的一部分**。

## 分层

## 实体

## 值对象

## 服务

服务的特征：

1. 服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。

2. 被执行的操作涉及到领域中的其他的对象。
3. 操作是无状态的。  



* 服务的概念也是分层的，例如领域层有自己的服务，基础设置层也有自己的服务。
* 不论是应用服务还是领域服务，通常都是建立在领域的实体对象和值对象之上  

> 注意：这里的服务是和**实体对等**的一个概念，**不要把它和应用层混淆**！！！

## 模块

## 聚合

## 工厂

## 资源库

工厂和资源库之间存在一定的关系。它们都是模型驱动设计中的模式，它们都能帮助我们管理领域对象的生命周期。然而工厂关注的是对象的创建，而资源库关注的是已经存在的对象。资源库可能会在本地缓存对象，但更常见的情况是需要从一个持久化存储中检索它们。  

# 面向深层理解的重构

# 保持模型的一致性

## 界定上下文

* **模型的上下文是一些条件的集合**，这些条件可以确保应用在模型里的**术语都有一个明确的含义**。  
* **界定上下文并不是模块**。界定的上下文提供有模型在其中进化的逻辑框架。**模块是被用来组织模型的元素，因此界定的上下文包含了模块**。  

* 每一个模型都有一个上下文。在我们处理一个独立的模型时，上下文是隐含的，我们不需要去定义它。  

* 采用多个模型（而不是一个单一的大模型），对任何大型项目都有帮助。

  * 如何将一个大的模型分解成小的模型没有什么固定的准则。
  * 尽量把那些**相关联的以及能形成一个自然概念的元素**放在一个模型里。模型应该足够小，以便能分配给一个团队去实现 。
  * 主要的思想是**定义模型的范围，定出它的上下文的边界**，然后尽最大可能保持模型的统一。  
  * 明确定义模型所应用的上下文，根据以下因素来明确设置边界：
    *   团队的组织结构
    * 应用的特定部分中的惯例、物理表现（例如代码库、数据库 Schema）

  > 总结：
  >
  > 1. 大模型划分为小模型是有益的
  > 2. 划分小模型的标准是定义边界上下文，而清洗边界上下文有下面会提及的若干方法。
  > 3. 定边界上下文的标准没有详细说明

## 持续集成

## 上下文映射

* 上下文映射（Context Map）是描绘不同的界定上下文和**它们之间关系**的一份文档
*   创建上下文映射的方法
  * 处理上下文之间的高级交互：共享内核，客户-供应商
  * 想让上下文高度独立：隔离通道  
  * 与遗留系统或外部系统的交互：开放主机服务，防崩溃层

## 共享内核（Shared Kernel）

* 共享内核的目的是减少重复，但是仍保持两个独立的上下文。  

## 客户-供应商（Customer-Supplier）  

有的时候两个子系统之间存在特殊的关系：一个子系统严重依赖另一个。两个子系统所在的上下文是不同的，并且一个系统的处理结果被作为另外一个的输入。它们没有共享的内核  

## 顺从者

* 如果客户不得不使用供应商团队的模型，而且这个模型做得很好，那么就需要顺从这个模型了。客户团队遵从供应商团队的模型，完全顺从它。这和共享内核很相似，但有一个重要的不同之处。客户团队不能对内核做更改。  

* 我们应该如何来实现防崩溃层？一个非常好的解决方案是将这个层看作来自客户端模型的一个服务。  

## 防崩溃层（Anticorruption Layer）  

**防崩溃层是模型天然的一部分，并不像一个外来的东西。它操作的是与我们的模型相似的概念和动作**，但是防崩溃层使用外部语言与外部模型交流，而不是客户端语言  

## 隔离通道

## 开放主机服务（Open Host Service）  

## 提炼