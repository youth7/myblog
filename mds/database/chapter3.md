## SQL的基本结构
### 一个SQL查询的逻辑理解  
* 首先，从from子句中生成笛卡尔积
* 然后，在笛卡尔积上面应用where子句指定的谓词
* 最后，对步骤2的结果，输出select限定的属性

**注意：这些步骤只是用来理解SQL执行的最终的结果，数据库在实际执行的时候会选择更加高效的方式**
###  SQL执行的顺序
因具体数据库实现的不同而不同，但是可以粗糙地认为按照以下顺序执行：  
`FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY  `  
根据这个规则可以判断一些别名是否可见的问题，例如select中的别名在order by中是必然可见的，因为order by 在select之后执行；而from 之后的别名则在所有子句中都可见



## 附加的基本运算
在where子句谓词的元组上直接使用比较运算符，例如
```sql
select name, course_id 
from instructor, teaches
where (instructor.ID, dept_name) = (teaches.ID, 'Biology');
```
**这个技巧的本质是SQL允许将几个标量组合为一个元组，然后直接以元组为单元进行比较**

## 集合运算
|操作类型|关键字|
|---|---|
|并|`union`|
|交|`intercept`|
|差|`except`|
  
## `NULL`
`NULL`和操作符、聚集函数一起使用的话，结果如下
|操作符|返回值|
|---|---|
|`NULL`和算术运算符|`NULL`|
|`NULL`比较运算符|`unknown`|
|`NULL`逻辑运算符|见下|
|`NULL`和狙击函数|除了`count(*)`外，其它聚集函数都会葫芦`NULL` <br> 注意仅仅是`count(*)`有这种效果，`count(列名)`还是会忽略`null`的行|     


除了以下两条，其它都返回unknown
* `true or unknown = true`
* `false and unknown = false`



如果想要保留重复，则可以在后面加上一个`all`

## 嵌套子查询
假设S为某个子查询所范围的结果。
* 用在where子句中的嵌套子查询  
    |作用|使用的关键字| 补充说明|
    |---|---|---|
    |检测元组是否在集合中|`in`|可以和逻辑运算符`not`搭配使用|
    |将元组与S中的部分元素比较|`some`|可以和比较运算符符`=   <>   >   >=      <   <=`组合使用 |
    |将元组与S中的全部元素比较|`all`|可以和比较运算符符`=   <>   >   >=      <   <=`组合使用|
    |检测S是否为空|`exist`|可以和逻辑运算符`not`搭配使用|
    |检测S是否存在重复元组|`unique`|可以和逻辑运算符`not`搭配使用|   
* 用在`from`子句中的嵌套子查询  
与在`where`子句中不同，这里的嵌套子查询**不能使用外层查询的变量**
* `with`子句  
将多个子查询预先定义好放在头部，以供后续的SQL主干使用。与写代码时候的原则一样，将枝干逻辑封装为一个函数。用with子句现将子查询定义好，则主干调用子查询时候相当于查询某个表，主干就非常清晰了。
* 标量子查询  
如果S只包含一个元组且只有一个属性，则可以当做标量使用在SQL中。

> 个人觉得，如果外层查询中不需要返回子查询中的结果给调用者，则这种类型的查询完全可以不用连接表，直接用子查询完成即可。当然，最为重要的原则还是要先符合业务的语意。