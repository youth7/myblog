## UART是如何区分读写模式的？

1. 读 LCR（0x3F8+0x03）→ 看 DLAB 位（第 7 位）→ 确定是 “波特率配置模式” 还是 “数据收发模式”；
2. 若为数据收发模式：
   - 读 LSR（0x3F8+0x05）→ DR 位（第 0 位）判断是否可读、THRE 位（第 5 位）判断是否可写；
   - 读 IIR（0x3F8+0x02）→ 看 FIFO 状态位（第 6、7 位）判断是否启用 FIFO；
3. 若为波特率模式：
   1. 地址偏移量为0的地方是DLL，存16位除数的低八位
   2. 地址偏移量为1的地方是DLM，存16位除数的高八位

> 16550 UART 偏移 0x02 的标准名称是 **Interrupt Identification Register（IIR，中断识别寄存器）**，并非 ISR（Interrupt Status Register，中断状态寄存器），这是术语混用导致的常见误解。

## 如果读写模式是可以同时存在的，那UART对同一个地址进行读写的时候， 数据不会错乱吗？

> 你的这个疑问直击 16550 UART 设计的核心 ——**“同一端口地址却能区分读写操作、甚至对应不同寄存器”，本质是硬件层面的 “地址 + 操作类型” 译码逻辑，和内存的 “同一地址 = 同一存储位置” 完全不同**。
>
> 简单说：UART 的 “端口地址” 不是 “内存地址”，它是 CPU 对硬件设备的 “访问编号”，硬件会根据「地址 + 读 / 写指令」来决定响应哪个寄存器，而非像内存那样 “地址唯一对应存储单元”。
>
> 下面分两层讲清楚这个逻辑：
>
> ### 一、先分清：内存访问 vs 外设端口访问（核心差异）
>
> | 维度     | 内存访问（RAM/ROM）                   | 外设端口访问（UART / 网卡）                |
> | -------- | ------------------------------------- | ------------------------------------------ |
> | 地址本质 | 物理存储单元的唯一编号（如 0x100000） | 硬件设备的 “访问通道编号”（如 0x3F8）      |
> | 读写逻辑 | 读 / 写同一地址 → 操作同一个存储单元  | 读 / 写同一地址 → 硬件译码后操作不同寄存器 |
> | 实现主体 | 内存控制器（被动响应，无逻辑判断）    | 外设硬件电路（主动译码，判断操作类型）     |
>
> 
>
> ### 二、16550 UART 同一地址区分读写的硬件实现
>
> 以 16550 最核心的端口 0x3F8 为例（DLAB=0 时）：
>
> - **写操作（out 指令）**：CPU 执行 `out 0x3F8, al` → 硬件检测到 “地址 = 0x3F8 + 写操作” → 激活「发送保持寄存器（THR）」的写入电路 → 将 AL 数据存入 THR；
> - **读操作（in 指令）**：CPU 执行 `in al, 0x3F8` → 硬件检测到 “地址 = 0x3F8 + 读操作” → 激活「接收缓冲寄存器（RBR）」的读取电路 → 将 RBR 数据送入 AL；
>
> #### 硬件译码逻辑示意图（简化版）：
>
> ```plaintext
> CPU 发出 → [地址信号（0x3F8）] + [读写控制信号（读/写）] → 16550 译码器
>           ├─ 地址匹配 0x3F8 + 写信号 → 选通 THR 寄存器
>           └─ 地址匹配 0x3F8 + 读信号 → 选通 RBR 寄存器
> ```
>
> 关键：THR 和 RBR 是物理上独立的两个寄存器，只是共享了同一个 “访问地址”，硬件通过「读写控制信号」来区分到底操作哪一个 —— 这和内存 “一个地址对应一个存储单元” 的逻辑完全不同。
>
> > - **RBR**：源自 16450/16550 的官方数据手册与 PC 体系结构标准，强调其 “缓冲” 属性 —— 数据从接收移位寄存器（RSR）移入后暂存，等待 CPU 读取，是只读寄存器。
> > - **RHR**：多见于部分嵌入式 UART 或简化教材，将其与发送侧的 THR（Transmit Holding Register）对称命名，但并非 16550 的标准术语。
>
> ### 三、再延伸：DLAB 位如何进一步复用地址？
>
> 你之前关注的 DLAB 位（LCR 第 7 位），是在 “地址 + 读写” 的基础上，增加了第二层译码条件：
>
> - **DLAB=1 时**：端口 0x3F8 对应「除数锁存低位（DLL）」（读 / 写都操作 DLL），端口 0x3F9 对应「除数锁存高位（DLM）」；
> - **DLAB=0 时**：端口 0x3F8 对应 RBR（读）/THR（写），端口 0x3F9 对应「中断使能寄存器（IER）」；
>
> #### 完整译码逻辑：
>
> ```plaintext
> CPU 信号 → [地址] + [读写] + [DLAB 位状态] → 16550 译码器
>           ├─ 地址=0x3F8 + 写 + DLAB=0 → 选通 THR
>           ├─ 地址=0x3F8 + 读 + DLAB=0 → 选通 RBR
>           ├─ 地址=0x3F8 + 写 + DLAB=1 → 选通 DLL
>           ├─ 地址=0x3F8 + 读 + DLAB=1 → 选通 DLL
>           └─ ... 其他地址/状态组合 ...
> ```
>
> 本质是：DLAB 位作为 “模式开关”，让同一地址在不同模式下对应不同寄存器 —— 硬件内部会把 DLAB 位的状态和地址、读写信号一起输入译码器，最终决定激活哪个寄存器的电路。
>
> ### 四、为什么要这么设计？（历史原因）
>
> 16550 诞生于早期计算机时代，当时 CPU 的 “I/O 端口地址资源有限”（比如 x86 架构早期只有 64KB I/O 地址空间），为了减少 UART 占用的端口数量，设计师采用了 “地址复用 + 读写区分 + 模式位切换” 的策略：
>
> - 16550 仅用 8 个端口地址（0x3F8~0x3FF），就实现了 10+ 个寄存器的访问；
> - 若每个寄存器都分配独立地址，会占用更多宝贵的 I/O 地址空间，不利于其他外设（如硬盘、显卡）的扩展。
>
> ### 五、和内存映射 I/O 的区别（补充）
>
> 现代外设也常用 “内存映射 I/O”（把外设寄存器映射到内存地址），但逻辑和 16550 一致：
>
> - 即使是内存映射的 UART 寄存器，同一地址的读 / 写也可能对应不同硬件寄存器（比如 ARM 的 UART DR 寄存器：读 = 接收数据，写 = 发送数据）；
> - 核心还是硬件译码，而非内存的 “地址 = 存储单元” 逻辑。
>
> ### 总结
>
> 16550 同一地址能区分读写、甚至对应不同寄存器，核心是：
>
> 1. UART 的 “端口地址” 是硬件访问编号，不是内存存储单元地址；
> 2. 硬件通过「地址 + 读写控制信号 + DLAB 模式位」的组合译码，决定操作哪个独立的物理寄存器；
> 3. 这是外设设计中 “地址复用” 的经典方案，目的是节省 I/O 地址资源。
>
> 简单记：**内存地址是 “一对一”（地址→存储单元），外设端口地址是 “多对一”（地址 + 操作 →寄存器）** —— 这就是为什么同一端口地址能实现读写独立。



# 寄存器列表

## LSR(Line Status Register)

| 位   | 值为0                       | 值为1                               |
| ---- | --------------------------- | ----------------------------------- |
| 0    | RHR或FIFO中没有数据         | RHR或FIFO中有数据                   |
| 1    | 无overrun错误               | 有overrun错误                       |
| 2    | 无奇偶校验错误              | 有奇偶校验错误                      |
| 3    | 无framing错误               | 有framing错误                       |
| 4    | 无break condition           | 接收到break信号                     |
| 5    | THR满了，不再接收并发送数据 | THR或者FIFO为空，可以加载下一个字符 |
| 6    | THR和TSR满了                | THR为空                             |
| 7    | 没有任何异常                | 发生了2、3、4位中的任一错误         |

