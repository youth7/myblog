# 静态链接和动态链接中的重定位

本文在Linux环境下进行阐述，并假设用户将源码编译为可执行文件。



## 基本概念

关于链接的定义：

> Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed.   

——《CSAPP》



> **Linking** refers to the creation of a single executable file from multiple object files. .  

——[Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)



> In [computing](https://en.wikipedia.org/wiki/Computing), a **linker** or **link editor** is a computer [system program](https://en.wikipedia.org/wiki/System_software) that takes one or more [object files](https://en.wikipedia.org/wiki/Object_file) (generated by a [compiler](https://en.wikipedia.org/wiki/Compiler) or an [assembler](https://en.wikipedia.org/wiki/Assembler_(computing))) and combines them into a single [executable](https://en.wikipedia.org/wiki/Executable) file, [library](https://en.wikipedia.org/wiki/Library_(computing)) file, or another "object" file.

——[《Wikipedia》](https://en.wikipedia.org/wiki/Linker_(computing))



需要区分清楚编译（compile）、汇编（assembly）、链接（link）、加载（load）这4个不同的概念，它们的关系如下：

![](/imgs/compile_link_load.jpg)

链接的主要内容：

1. 地址与空间分配

   扫描各个目标文件，把里面的节按照类型合并起来，同时收集目标文件中的**符号引用**和**符号定义**到一个全局的集合中。完成这个步骤后得到可执行文件的整体结构已经确定，但其中一些符号的地址还需要重定位。

2. 符号解析和重定位

   根据步骤1中收集到的符号信息，为需要重定位的符号分配具体地址。这一步是链接的重中之重。静态链接的重定位在链接时就发生了，动态链接则将这个步骤推迟到程序加载或者运行时。



需要注意的是，编译时编译器为程序分配的地址空间都是从0开始的，此时并**没有面向虚拟地址空间（运行在支持虚拟地址的OS上）或者物理内存地址空间（运行在裸机上）**。不同的编译套件会根据自身的编译目标（target triple）在**链接阶段重置代码的基地址**。重置基地址并不会进行符号解析和重定位（在动态链接的例子中会展示），符号解析和重定位会发生在最后。





## 静态链接和动态链接的区别

链接阶段最重要的内容是符号解析和重定位，静态链接会在生成可执行文件的时候完成链接阶段的全部内容，而动态链接则会把这两个工作中的部分内容（例如解析动态链接库中的符号并进行重定位）推迟到运行时。

网上很多资料都说静态链接是*编译时*链接，其实这说话是不准确的。由上图可知编译包括：

1. 源代码编译到汇编代码

2. 汇编代码编译到目标文件

所以编译和链接的工作内容是完全不同的，编译并没不包含链接。但上面的错误说法其实也是可以理解的，他将编译+链接流程划分来两个阶段：*编译时*和*运行时*，*编译时*包括编译和链接，*运行时*包括程序加载和运行。因此"静态链接是*编译时*链接"这句话主要指静态链接在**运行前就完成了符号解析和重定位的工作**

[这个回答](https://stackoverflow.com/questions/311882/what-do-statically-linked-and-dynamically-linked-mean)中提到：

> You can see in the static case that the main program and C runtime  library are **linked together at link time**(by the developers). Since the  user typically cannot re-link the executable, they're stuck with the  behaviour of the library.   

> In the dynamic case, the main program is linked with the C runtime  import library (**something which declares what's in the dynamic library  but doesn't actually *define* it**). **This allows the linker to link even though the actual code is missing**.   

> Then, at runtime, the operating system loader does a late linking of  the main program with the C runtime DLL (dynamic link library or shared  library or other nomenclature).    

> The owner of the C runtime can drop in a new DLL at any time to  provide updates or bug fixes. As stated earlier, this has both  advantages and disadvantages.  

```sql
Phase     Static                    Dynamic
--------  ----------------------    ------------------------
          +---------+               +---------+
          | main.c  |               | main.c  |
          +---------+               +---------+
Compile........|.........................|...................
          +---------+ +---------+   +---------+ +--------+
          | main.o  | | crtlib  |   | main.o  | | crtimp |
          +---------+ +---------+   +---------+ +--------+
Link...........|..........|..............|...........|.......
               |          |              +-----------+(注意：这里crtimp没有像静态链接的crtlib那样完全打包进main中)
               |          |              |
          +---------+     |         +---------+ +--------+
          |  main   |-----+         |  main   | | crtdll |
          +---------+               +---------+ +--------+
Load/Run.......|.........................|..........|........
          +---------+               +---------+     |
          | main in |               | main in |-----+
          | memory  |               | memory  |
```





## 静态链接例子分析

为了简化问题，使用以下两个C语言程序进行编译和链接的演示

文件`a.c`的源码：

```c
extern int shared;

int main(void)
{
    int a = 100;
    swap(&a, &shared);
}
```

文件`b.c`的源码：

```c
int shared = 1;
void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```



其中编译环境信息为：

* 操作系统：Ubuntu 20.04.4 LTS

* 编译工具：[riscv64-unknown-elf.gcc-12.1.0](https://github.com/stnolting/riscv-gcc-prebuilt/releases/download/rv64imc-3.0.0/riscv64-unknown-elf.gcc-12.1.0.tar.gz)

使用该编译套件是因为RISCV历史包袱少，它的汇编代码比X86和ARM更加易懂。（关于编译套件命名规则可以参考[这里](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html#id5)）



使用以下命令进行编译和链接：

```bash
#编译源代码但不链接
riscv64-unknown-elf-gcc -c a.c b.c

#链接上一步生成的目标文件
riscv64-unknown-elf-ld a.o b.o -e main -o ab

```

各个文件的作用如下：

* `a.o`：文件`a.c`编译后生成的目标文件

* `b.o`：文件`b.c`编译后生成的目标文件

* `ab`：文件`a.o`和`b.o`链接后的产物

### 链接前

从上述代码可知`a.c`引用了`b.c`中定义的全局变量，我们用`riscv64-unknown-elf-objdump -d a.o ab`来对比一下链接前后的`main`程序的汇编代码

```
a.o:     file format elf64-littleriscv


Disassembly of section .text:

0000000000000000 <main>:
   0:	1101                	addi	sp,sp,-32
   2:	ec06                	sd	ra,24(sp)
   4:	e822                	sd	s0,16(sp)
   6:	1000                	addi	s0,sp,32
   8:	06400793          	li	a5,100
   c:	fef42623          	sw	a5,-20(s0)
  10:	fec40713          	addi	a4,s0,-20
  14:	000007b7          	lui	a5,0x0
  18:	00078593          	mv	a1,a5
  1c:	853a                	mv	a0,a4
  1e:	00000097          	auipc	ra,0x0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>
  26:	4781                	li	a5,0
  28:	853e                	mv	a0,a5
  2a:	60e2                	ld	ra,24(sp)
  2c:	6442                	ld	s0,16(sp)
  2e:	6105                	addi	sp,sp,32
  30:	8082                	ret

ab:     file format elf64-littleriscv


Disassembly of section .text:

00000000000100e8 <main>:
   100e8:	1101                	addi	sp,sp,-32
   100ea:	ec06                	sd	ra,24(sp)
   100ec:	e822                	sd	s0,16(sp)
   100ee:	1000                	addi	s0,sp,32
   100f0:	06400793          	li	a5,100
   100f4:	fef42623          	sw	a5,-20(s0)
   100f8:	fec40713          	addi	a4,s0,-20
   100fc:	67c5                	lui	a5,0x11
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>
   10102:	853a                	mv	a0,a4
   10104:	010000ef          	jal	ra,10114 <swap>
   10108:	4781                	li	a5,0
   1010a:	853e                	mv	a0,a5
   1010c:	60e2                	ld	ra,24(sp)
   1010e:	6442                	ld	s0,16(sp)
   10110:	6105                	addi	sp,sp,32
   10112:	8082                	ret

```

可见在编译的时候，编译器对`main`中调用`swap`的生成了以下代码：

```
  14:	000007b7          	lui	a5,0x0	#计算shared地址的高20位，因为它暂时未知，所以暂设为0
  18:	00078593          	mv	a1,a5	#加载swap的第1个参数的地址到a1
  1c:	853a                	mv	a0,a4	#加载swap的第2个参数（即shared）的地址到a0
  1e:	00000097          	auipc	ra,0x0	#加载swap地址，将"立即数高20位"加上"PC当前值"存到ra，因为swap地址此时未知，因此立即数为0
  22:	000080e7          	jalr	ra # 1e <main+0x1e>	#调用swap，这个伪指令相当于jalr x1, ra, 0 
```

这里有点奇怪的是计算`shared`地址的时候，不知道为何只包含了计算地址高20位的指令，没有包含低12位的计算。

`auipc`+`jalr`的作用如下：

* [AUIPC](https://jemu.oscc.cc/AUIPC) 与 [JALR](https://jemu.oscc.cc/JALR) 的 12 位立即数配合, 可以将控制流跳转到相对于 `PC` 的、32 位整型范围内的任意地址;

* 其中`auipc ra, 0x0`计算了`PC` + `swap`地址的前20位（存在常数参数中，即此例中的0x0），并存在`ra`中
* `jalr ra`扩展后相当于`jalr x1, ra, 0`，用上一步的结果（存在`ra`中），加上`swap`地址的低12位（存在常数参数中，即此例中的0x0）

注意这里只是编译时的结果，链接时当所有符号的地址都确定后，链接器会优化函数调用的过程（链接器松弛），下面我们会看到。



用`readelf -r a.o`检查一下重定位表：

```
Relocation section '.rela.text' at offset 0x1f0 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000014  00090000001a R_RISCV_HI20      0000000000000000 shared + 0
000000000014  000000000033 R_RISCV_RELAX                        0
000000000018  00090000001b R_RISCV_LO12_I    0000000000000000 shared + 0
000000000018  000000000033 R_RISCV_RELAX                        0
00000000001e  000a00000012 R_RISCV_CALL      0000000000000000 swap + 0
00000000001e  000000000033 R_RISCV_RELAX                        0

```

发现有`shared`有两个相关项，类型分别是`R_RISCV_HI20`和`R_RISCV_LO12_I`，它代表了`shared`的高20位和低12位都需要重定位。`swap`则更加不用说了，类型为`R_RISCV_CALL`，关于它的详细解读请参考[RISC-V ELF Specification](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#risc-v-elf-specification)

### 链接后

而经过链接之后则变成这样，主要是对重定位表中的符号进行重定位。

```
   100fc:	67c5                	lui	a5,0x11	#计算shared地址的高20位，此时因为已经将b.o也合并进来，所以编译器能够计算出它的地址
   100fe:	17478593          	addi	a1,a5,372 # 11174 <shared>	#加上低12位得出shared的最终地址
   10102:	853a                	mv	a0,a4		#为swap传参
   10104:	010000ef          	jal	ra,10114 <swap>	#函数调用
```

用`readelf  -s ab`显示一下符号表：

```
Symbol table '.symtab' contains 19 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
...
    11: 0000000000010114    94 FUNC    GLOBAL DEFAULT    1 swap
    12: 0000000000011174     4 OBJECT  GLOBAL DEFAULT    2 shared
  
```

其中`shared`的计算方式为：高20位地址 + 低12位地址，其中高20位由指令`lui a5,0x11`确定，其值为0x11 << 12 =  69632。低12位为372，所以最终的地址为 69632 + 372 = 70004 = 0x11174，和符号表的结果完全一致。



而`swap`的调用则由之前的`auipc`+`jalr`改为了`jal ra,10114`，这就是下面说的“链接器松弛”技术



关于RISC-V汇编代码的一些基础知识可以参考：

* [RISC-V指令集讲解（5）条件和无条件跳转指令](https://zhuanlan.zhihu.com/p/394860078)
* 《RISC-V手册》前三章

其中一些重要的点是：

* 由于在单个 32 位指令中很难指定一个 32 位的地址，RV32I 的链接器通常需要为每个标签调整两条指令。
* 补充说明：链接器松弛（linker relaxation）
  跳转并链接指令（jump and link）中有 20 位的相对地址域，因此一条指令就足够跳到很远的位置。**尽管编译器为每个外部函数的跳转都生成了两条指令，很多时候其实一条就已经足够了。从两条指令到一条的优化同时节省了时间和空间开销，因此链接器会扫描几遍代码，尽可能地把两条指令替换为一条**。每次替换会导致函数和调用它的位置之间的距离缩短，所以链接器会多次扫描替换，直到代码不再改变。这个过程称为链接器松弛，名字来源于求解方程组的松弛技术。除了过程调用之外，对于 gp 指针±2KiB 范围内的数据访问， RISC-V 链接器也会使用一个全局指针替换掉 lui 和 auipc 两条指令。对 tp 指针±2KiB 范围内的线程局部变量访问也有类似的处理。  
* 一般来说，`LUI`和`JALR`配合使用可以跳转**32位绝对地址**范围，`AUIPC`和`JALR`配合可以跳转32位**相对于PC的**地址范围
* https://stackoverflow.com/questions/64695981/what-does-jalr-with-only-1-argument-and-offset-do



### 与x86的对比

再用系统自带的gcc套件重复上述过程，对比一下编译的结果

```bash
#编译源代码但不链接，注意需要加上-fno-stack-protecto否则会报错	
gcc -fno-stack-protector -c a.c b.c

#链接上一步生成的目标文件
ld a.o b.o -e main -o ab
```

TODO：分析上面的x86上的静态链接



### 总结

与动态链接相比，静态链接最大的特点是**链接时重定位**（动态链接是运行时重定位），而具体的重定位细节跟平台的指令集相关，学习时不必执着于地址的某些计算过程，只需知道链接器合理合并了所有目标文件并确定最终地址，然后进行最后的重定位。





## 动态链接

静态链接的优点是生成的可执行文件能够独立执行，不需要额外的依赖，毕竟静态链接将所有第三方依赖都打包到可执行文件中了。但缺点也很明显：

* 体积大
* 浪费内存
* 升级更新难

动态链接的出现就是为了克服上述问题。它的做法是不在链接时将依赖的目标文件（假设就是lib.so）打包到可执行文件中，而是将lib.so加载到内存中（只有一份），当程序运行时用到lib.so中的对象，直接去内存中对应的地址读取即可，这种做法解决了上述的3个问题。

> lib.so被加载到多个进程的虚拟地址空间中，这样不就加载了多次吗，为何说它只有一份呢？事实上操作系统确实只加载了一份lib.so到物理内存，然后将lib.so映射到不同进程的虚拟地址空间中来实现共享。具体的过程可以参考：[动态链接器如何判断某个共享库已经加载进内存? - ruanyuanyu的回答 - 知乎](https://www.zhihu.com/question/270473854/answer/354570620)



因为lib.so在链接时不会被打包到可执行文件中，因此可执行文件对lib.so中各种符号的地址一无所知，只能在运行时等动态链接器把lib.so加载到进程的虚拟地址空间后，才能确定各个符号的值，进而访问lib.so中的各种对象。



### 基址重置的缺陷









## 参考

* [Linking & Loading](https://www.cs.fsu.edu/~baker/opsys/notes/linking.html)
* [Compiling and Linking](https://www.cprogramming.com/compilingandlinking.html)
