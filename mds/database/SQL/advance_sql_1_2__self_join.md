## 内连接的关键点总结

* 将内连接的视为两个恰好一模一样的表进行连接
* 将表看做元素的集合，则内连接产生的是有序对（即排列）。通过添加过滤条件能够排除某些有序对，从而实现去重
* 将表看做递归集合，还能实现实现排序的功能

## 实际应用

### 从有序对的角度去重

例如有product表如下

| name | price |
| ---- | ----- |
| 橘子 | 100   |
| 苹果 | 50    |
| 香蕉 | 80    |

现在希望产生下表

| name1 | name2 |
| ----- | ----- |
| 苹果  | 橘子  |
| 香蕉  | 橘子  |
| 香蕉  | 苹果  |

则可以通过以下sql进行

```sql
select
	p1.name as name1,
	p2.name as name2
from
	products p1 ,
	products p2
where
	p1.name > p2.name
```

原理是通过自连接产生一组有序对，然后再通过`where`子句过滤掉某些包含相同元素的有序对，从而达到去重效果。可以观察一下不加`where`子句的查询结果，通过对比更容易理解这个技巧的原理。这个技巧的另外一个运用是生成对阵表，例如世界杯小组赛有若干支队伍，使用这个技巧能够快速生成对阵表



### 从集合的角度进行排序



假设有下表

| name | price |
| ---- | ----- |
|柠檬	|30|
|橘子	|10|
|苹果	|50|
|葡萄	|50|
|西瓜	|80|
|香蕉	|50|



然后我们希望按照price进行排序，从而得到下表

| name | price |rank1 | rank2 |
| ---- | ----- |---- | ----- |
|橘子 |100 |1 |1|
|西瓜 |80  |2 |2|
|苹果 |50  |3 |3|
|香蕉 |50  |3 |3|
|葡萄 |50  |3 |3|
|柠檬 |30  |6 |4|

rank1和rank2的区别是如果同一价格有多条符合条件的记录，则紧跟着的排序序号是否需要跳过。这个问题可以用窗口函数轻易解决，但也可以使用子查询解决



```sql
select 
	name, 
	price,
	(select count(price ) from products p2 where p2.price<p1.price) + 1 as rank1,
	(select count( distinct price ) from products p2 where p2.price<p1.price) + 1 as rank2
from 
	products p1 
order by 
	rank1
```

其核心原理是递归集合，子查询所做的，是计算出价格比自己低的记录的条数，并将其作为自己的排序序号。递归集合集合非常简单，不需要join等花里胡哨的东西，只需要一个**关联子查询，并在关联子查询里面指定查询条件和聚合函数**。其中查询条件最为关键，它是递归集合能否生成的前提条件  

个人觉得用连接似乎更容易表现递归集合的生成过程，例如可以通过以下两步来理解递归结合

```sql
select
	P1.name,
	P2.name ,
	P1.price
from
	Products P1
left outer join Products P2 on
	P1.price < P2.price
```

运行并观察结果可知，这段sql非常清晰表达出递归包含的意思，在此基础上加上`group by`则可满足排序的需求



