企业架构模式学习笔记

总的来说，这本书很多具体的技术已经相当过时了（毕竟成书时间是2002年！），只要少部分的理念（例如领域层和数据源层的组织）还有价值。通过领域层的组织方式我们知道DDD在项目的架构里面只是非常小的一个部分。



# 引言

章节结构：第一部分是一个综述，描述了**企业应用架构**中的一些基础知识。第二部分是**针对各种具体问题而提出的解决方案**（也可以认为是针对不同问题的分层方法）。

全书主要讨论如何将企业应用组织成不同的层次，即讨论分层架构。而分层架构是单体架构中的其中1种，其它的架构风格有管道架构、微内核架构。（[关于架构、微服务、DDD之间的关系可以参考这篇文章的附录](./architecture_principle.md)）

这一章讨论了以下内容：

* 架构的定义
* 什么是企业应用
* 什么是模式



## 架构的定义

架构的定义难以统一，但一般会包含以下内容：

* 最高层次的系统分解
* 系统中不易改变的决定

Ralph Johnson认为，架构是主观的（这个不是很好理解），它描述了**系统的组成部分以及这些组成之间的关系**。而作者认为，架构涉及**企业应用主要组成部分**和他希望**尽可能做出的决定**。

> 关于架构的定义和相关方法论，目前来看最好的应该是《**软件架构：架构模式、特征及实践指南**》了，该书从极高的高度描述了架构相关的方法论。

## 企业应用的特点

与一些底层软件开发（例如数据库或者OS开发）对比，企业应用有以下特点：

* 涉及持久化数据
* 涉及大量数据
* 很多人同时访问数据
* 大量操作数据的客户端
* 与散布在周围的其他企业应用集成

## 模式

模式的核心就是特定的解决方案，它有效而且有足够的通用性，能解决重复出现的问题。



# 第一部分：表述

## 分层

分层架构中最难的问题是决定建立哪些层次以及各层的职责。

> 在英语上*layer*和*tier*都能表示“层”这个概念，但多数人认为*tier*意味着物理的分离，而这里讨论的更多是逻辑上的分层，不一定意味着是物理分离，因此用*layer*更加合适。

在企业应用中可以分出三个基本的层次：

* 表现层
* 领域逻辑层
* 数据源层

接下来讨论了为各层选择运行环境的问题，理论上除了数据源层需要运行在服务端，其它两层可以根据应用的性质在选择部署在服务端或客户端，而这些方案各有优劣。企业应用发展到现在，表现层基本上是以WEB界面为主的瘦客户端，因此三层都可以运行在服务端。

相比之下大型的3D游戏的架构方式和企业应用确实有明显的区别，首先它需要部署在客户机上的胖客户端，一些必要的业务逻辑也会运行在胖客户端上。

不要把**MVC设计模式**和**工程的三层架构**混淆，三层结构指的是**表现层、业务层、数据持久层**。而MVC只针对**表现层进行设计**。

## 如何组织领域逻辑

领域逻辑的组织有三种主要模式：

| 名称                   | 优点                       | 缺点                                                     |
| ---------------------- | -------------------------- | -------------------------------------------------------- |
| 事务脚本               | 简单直接                   | 容易产生不易消除的重复代码，且难以描述日益复杂的业务逻辑 |
| 领域模型               | 能够抽象复杂的业务         | 复杂，使用难度大                                         |
| 表模块（Table Module） | 难度和抽象能力位于两者之间 | 难度和抽象能力位于两者之间                               |

注意表模块**不是数据源层的抽象，是业务逻辑的组织方式，不要将它和数据源层的*Table Data Gateway*混淆**。

* 表模块类作为一个容器，将数据和行为组合在一起。业务逻辑被拆分为粗粒度的，表示整个数据表的组件。但实际上它**只有在.NET+VS Studio的条件下才有比较好的技术支持（参考[这里](https://www.cnblogs.com/Leo_wl/p/3216559.html)），其它平台根本不会考虑用这种方式来组织业务逻辑，基本上它是一个鸡肋  **。
* 使用表模块和领域模型的时候，可能会细分出一个位于它们之上的服务层，可以在服务层中放置事务控制和安全控制。服务层中放置多少业务逻辑是一个微妙的事情。（业务逻辑的多少会产生对应的[失血、贫血、充血、涨血模型](https://www.jianshu.com/p/c61c9d8478f4)？）

关于表模块和服务层的一些细节会在模式的章节里详细讨论，这里不展开。



## 映射到RMDB

由于长期使用MongoDB，这个章节看得并不是十分理解，因为面向对象数据库的出现使得ORM成为了多余。

本节分为两个部分：**架构**和**行为**。

***架构***讨论了一些模式，这些模式将领域逻辑层（DDD/事务脚本/表模块）访问数据库的细节（例如SQL）封装起来，它采用了一个称为*入口(Gateway)*的技术。入口主要有两种：*行数据入口(Row Data Gateway)*和*表数据入口(Table Data Gateway)*。

* 当使用表模块的时候，Gateway非常适合。

* 当使用领域对象的时候，最好选择*活动记录(Active Record)*、*数据映射器(Data Mapper)*作为首选持久化机制，同时使用Gateway来封装被视为外部接口的表或者服务。

***行为***讨论的是如何把各种对象从数据库中读取出来以及存到数据库中。

>  行为这个章节太过于晦涩，稍后回来补充内容

## WEB表现层

总体来说这个章节过时了（毕竟是20年前的著作了），很多东西也说得不清不楚的（例如MVC），前后端分离才是现在主流和未来，具体可以参考：

* [ SpringMvc demo示例及源码详细分析 （强烈推荐，说清楚MVC，并指出不能混淆MVC和三层架构）](https://www.cnblogs.com/chenyanbin/p/11930086.html)
* [《SSR 与当年的 JSP、PHP 有什么区别》](https://segmentfault.com/a/1190000037793694)
* 《[有必要使用服务器端渲染(SSR)吗？ - justjavac的回答](https://www.zhihu.com/question/308792091/answer/573586609)》

关于MVC这个无法理解的鸡肋我赞同这段话：

> 目前来说是的。MVC是历史遗留产物，在微服务普及的时代已经是淘汰的分层理论了。
>
> **Controller层在以前的单体架构中承担与UI对接的责任**。然而在前后端分离的场景，微服务应该**关注于服务本身**而与视图无关。目前的主流做法是使用api层替代controller层。
>
> 可能有人会提及Controller还能起到统一封装返回体或者数据验证，聚合各个service的作用。其实这种做法也是职责混乱的。数据验证，聚合逻辑放到service本身即可。
>
> 另外api层只需要返回最原始结果的JSON，**不需要额外封装和对数据进行处理，数据处理是UI自己需要做的事**。**service只服务于业务而不是服务于视图层**
>
> 作者：春风翻书
> 链接：https://www.zhihu.com/question/434308424/answer/1669963002

还有：

> * 不要把**MVC设计模式**和**工程的三层架构**混淆，三层结构指的是**表现层、业务层、数据持久层**。而MVC只针对**表现层进行设计**。
>
> * 表现层也就是我们常说的web层。它负责**接收客户端请求，向客户端响应结果**。

个人认为，在传统的SSR中（例如JSP），表现层的模式确实是MVC，整个表现层都由后端实现。但随着前后端分离CSR称为主流，表现层的一些工作分摊到前端去了，虽然表现层依然存在，但工作模式不再是严格的MVC了。

另外，个人认为当MVC中的M指业务模型的时候，只能调用领域逻辑层的方法，不应该自己实现领域逻辑，因为MVC是表现层的东西。

## 并发

这一章也稍显过时了，了解并发最好的书籍是《数据库系统概念》中相关章节，只需要理清楚两个问题：

* 隔离级别：读已提交/读未提交/可重复读/串行化
* 并发控制手段：锁/时间戳/基于有效性检查/快照隔离

对于微服务中的分布式事务书中几乎没有涉及（只提及了一个业务事务的概念），在当年来说这是一个非常陌生的领域，而现在的SAGA事务技术解决了这个问题。

而对于应用服务器的并发技术，只谈论了多线程/多进程两种，因为基于事件驱动的单线程并发模型尚未诞生。



## 会话状态

没什么特别需要注意的内容，内容不深入且显得过时，主要留意几个问题：

* 状态是服务端保存（session机制）还是客户端保存（token机制）
* session机制和token机制的优缺点，session机制下服务端能够控制状态的生命周期（通过销毁保存在服务端的session信息），但在分布式情况下的状态共享是一个问题，可以通过分布式缓存或者黏性会话来解决问题。而token机制的优缺点恰好和session相反。

## 分布策略

内容依旧显得过时，但难能可贵的是作者在20年前就提及了同步通讯VS异步通讯。

* 分布式对象（跨进程的对象）基于性能因素，只能使用粗粒度的抽象，这会导致**各个接口之间充满了相似的数据，同时也会导致接口数量迅速增加**。因此需要避免使用分布式对象。
* 如果一定要使用分布式对象，则使用*远程外观*+*数据传输对象*来解决这个问题（远程外观的思想有点像微服务中的BFF）。
* 文中讨论了分布式接口，其本质是*基于二进制的远程调用 VS 基于文本的远程调用*。在文章编写的时代，webservice + XML在异构平台之间交流信息有优势，而二进制的消息通讯更适合于同构平台且更加高效。然而发展了十多年之后，类似gRPC之类的技术得到了发展，基于二进制消息的通讯甚至在异构平台之间也得到了广泛应用。

## 通盘考虑

这一章是对上面几个要素的总结并给出了具体的结论，但这些技术基本显得过时。对Java体系来说，EJB已经绝迹，JavaEE也被Spring封装到底层很少直接使用，而JPA在当时则根本没有出现。

* 领域逻辑层：

  简单的业务用事务脚本，复杂的用领域模型。用领域模型最大的障碍就是**学习的难度**，以及领域模型和RDBMS之间的映射（ORM）。表模块这种需要工具和平台支持的直接忽略。

* 数据源层：

  * 事务脚本：使用行数据入口或者表数据入口，具体根据平台的支持以及系统。

  * 领域模型：领域模型简单的时候采用*活动记录*、*表数据入口*、*行数据入口*；复杂的时候数据映射器。

  * 表模块：略

* 表现层：略



**关于存储过程**

优点是快，缺点是缺少结构化的标准，容易和具体的数据库实现绑定起来导致难以移植。无论是使用SQL还是存储过程，将它们封装起来都是必须的，这就是JPA的意义。

将各种可变的层（如J2EE、JPA）都抽象出来后，最终演变成一个类似EJB的整体规范。但EJB太重了，随后被Spring家族取代，Spring boot就是Java Web开发的事实规范。



**关于WebService**

* 可以单体就不要用分布式。
* 用分布式的话，可以选择二进制消息或者文本消息进行通讯
* 用文本消息的话，除非是特殊场景，否则轻量的JSON优于XML

结论：

* 强大但笨重的XML在大部分领域基本被淘汰（在UI数据描述领域上XML或许表现更好，以为此时需要精细的数据描述能力）
* 过时，即使是跨平台的RPC，RESTful和gRpc已经完全可以满足要求，不再需要WebService这种过度封装的东西，WebService在HTTP上再添加一层SOAP看起来就是多余。WebService的优点就是各个平台的WebService类库能够将HTTP返回的东西重新封装为调用者平台的数据结构，这有点像SDK。



**其他的分层方式**

略，因为基本上很难 ，基本上就是三层方式的细分，其实只要实际需要，完全可以在三层架构基础添加新的层，不必拘泥于任何一种特定的分层方式。



# 第二部分：模式



